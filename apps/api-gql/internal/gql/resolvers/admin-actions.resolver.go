package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"errors"
	"fmt"

	"github.com/google/uuid"
	model "github.com/satont/twir/libs/gomodels"
	"github.com/twirapp/twir/apps/api-gql/internal/gql/gqlmodel"
	"github.com/twirapp/twir/libs/bus-core/eventsub"
	"gorm.io/gorm"
)

// DropAllAuthSessions is the resolver for the dropAllAuthSessions field.
func (r *mutationResolver) DropAllAuthSessions(ctx context.Context) (bool, error) {
	keys, err := r.redis.Keys(ctx, "scs:*").Result()
	if err != nil {
		return false, fmt.Errorf("failed to get session keys: %w", err)
	}

	if len(keys) == 0 {
		return true, nil
	}

	err = r.redis.Del(ctx, keys...).Err()
	if err != nil {
		return false, fmt.Errorf("failed to delete sessions: %w", err)
	}

	return true, nil
}

// EventsubSubscribe is the resolver for the eventsubSubscribe field.
func (r *mutationResolver) EventsubSubscribe(
	ctx context.Context,
	opts gqlmodel.EventsubSubscribeInput,
) (bool, error) {
	existedSubscription := model.EventsubTopic{}
	if err := r.gorm.
		WithContext(ctx).
		Where("topic = ?", opts.Type).
		First(&existedSubscription).
		Error; err != nil && !errors.Is(err, gorm.ErrRecordNotFound) {
		return false, nil
	}

	if existedSubscription.Topic != "" {
		return false, fmt.Errorf("subscription already exists")
	}

	condition, err := r.eventSubGqlToCondition(opts.Condition)
	if err != nil {
		return false, fmt.Errorf("failed to convert condition: %w", err)
	}

	newTopic := model.EventsubTopic{
		ID:            uuid.New(),
		Topic:         opts.Type,
		Version:       opts.Version,
		ConditionType: condition,
	}

	if err := r.gorm.
		WithContext(ctx).
		Create(&newTopic).
		Error; err != nil {
		return false, fmt.Errorf("failed to create topic: %w", err)
	}

	var channels []model.Channels
	if err := r.gorm.
		WithContext(ctx).
		Select("id", `"isEnabled"`).
		Where(`"isEnabled" = ?`, true).
		Find(&channels).Error; err != nil {
		return false, fmt.Errorf("failed to get channels: %w", err)
	}

	for _, channel := range channels {
		go func() {
			r.twirBus.EventSub.Subscribe.Publish(
				eventsub.EventsubSubscribeRequest{
					ChannelID: channel.ID,
				},
			)
		}()
	}

	return true, nil
}
