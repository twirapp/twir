package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"fmt"
	"log/slog"
	"strings"

	"github.com/Masterminds/squirrel"
	model "github.com/satont/twir/libs/gomodels"
	data_loader "github.com/twirapp/twir/apps/api-gql/internal/gql/data-loader"
	"github.com/twirapp/twir/apps/api-gql/internal/gql/gqlmodel"
	"github.com/twirapp/twir/apps/api-gql/internal/gql/graph"
)

// TwitchProfile is the resolver for the twitchProfile field.
func (r *communityUserResolver) TwitchProfile(
	ctx context.Context,
	obj *gqlmodel.CommunityUser,
) (*gqlmodel.TwirUserTwitchInfo, error) {
	user, err := data_loader.GetHelixUser(ctx, obj.ID)
	if err != nil {
		return nil, err
	}
	if user == nil {
		return nil, nil
	}

	return &gqlmodel.TwirUserTwitchInfo{
		Login:           user.Login,
		DisplayName:     user.DisplayName,
		ProfileImageURL: user.ProfileImageURL,
		Description:     user.Description,
	}, nil
}

// CommunityResetStats is the resolver for the communityResetStats field.
func (r *mutationResolver) CommunityResetStats(
	ctx context.Context,
	typeArg gqlmodel.CommunityUsersResetType,
) (bool, error) {
	user, err := r.sessions.GetAuthenticatedUser(ctx)
	if err != nil {
		return false, err
	}

	dashboardId, err := r.sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return false, err
	}

	if user.ID != dashboardId {
		return false, fmt.Errorf("you cannot reset stats for this user")
	}

	if typeArg == gqlmodel.CommunityUsersResetTypeUsedEmotes {
		err := r.gorm.WithContext(ctx).
			Where(`"channelId" = ?`, user.ID).
			Delete(&model.ChannelEmoteUsage{}).Error
		if err != nil {
			return false, err
		}

		return true, nil
	}

	var field string

	switch typeArg {
	case gqlmodel.CommunityUsersResetTypeMessages:
		field = "messages"
	case gqlmodel.CommunityUsersResetTypeWatched:
		field = "watched"
	case gqlmodel.CommunityUsersResetTypeUsedChannelsPoints:
		field = "usedChannelPoints"
	}

	if field == "" {
		return false, fmt.Errorf("unknown reset typeArg: %s", typeArg)
	}

	err = r.gorm.WithContext(ctx).
		Model(&model.UsersStats{}).
		Where(`"channelId" = ?`, dashboardId).
		Update(field, 0).Error
	if err != nil {
		return false, err
	}

	return true, nil
}

// CommunityUsers is the resolver for the communityUsers field.
func (r *queryResolver) CommunityUsers(
	ctx context.Context,
	opts gqlmodel.CommunityUsersOpts,
) (*gqlmodel.CommunityUsersResponse, error) {
	var page int
	perPage := 20

	if opts.Page.IsSet() {
		page = *opts.Page.Value()
	}

	if opts.PerPage.IsSet() {
		perPage = *opts.PerPage.Value()
	}

	// get sql.DB instance
	db, err := r.gorm.DB()
	if err != nil {
		return nil, err
	}

	channel := &model.Channels{}
	err = r.gorm.
		WithContext(ctx).
		Where("channels.id = ?", opts.ChannelID).
		Joins("User").
		First(channel).Error
	if err != nil {
		return nil, err
	}

	queryBuilder := squirrel.StatementBuilder.PlaceholderFormat(squirrel.Dollar).
		Select(`users_stats.*, COUNT("channels_emotes_usages"."id") AS "emotes"`).
		From("users_stats").
		LeftJoin(`"channels_emotes_usages" ON "channels_emotes_usages"."userId" = "users_stats"."userId" AND "channels_emotes_usages"."channelId" = "users_stats"."channelId"`).
		Where(
			squirrel.And{
				squirrel.Eq{`"users_stats"."channelId"`: opts.ChannelID},
				squirrel.NotEq{`"users_stats"."userId"`: opts.ChannelID},
				squirrel.NotEq{`"users_stats"."userId"`: channel.BotID},
				squirrel.Gt{`"users_stats"."messages"`: 0},
			},
		).
		Where(`NOT EXISTS (select 1 from "users_ignored" where "id" = "users_stats"."userId")`).
		Limit(uint64(perPage)).
		Offset(uint64(page * perPage)).
		GroupBy(`"users_stats"."id"`)

	var sortBy string
	if opts.SortBy.IsSet() {
		switch *opts.SortBy.Value() {
		case gqlmodel.CommunityUsersSortByMessages:
			sortBy = "messages"
		case gqlmodel.CommunityUsersSortByUsedChannelsPoints:
			sortBy = "usedChannelPoints"
		case gqlmodel.CommunityUsersSortByUsedEmotes:
			sortBy = "emotes"
		case gqlmodel.CommunityUsersSortByWatched:
			sortBy = "watched"
		}
	}

	if sortBy != "" && !opts.Order.IsSet() {
		queryBuilder = queryBuilder.OrderBy("watched DESC")
	} else if sortBy != "" && opts.Order.IsSet() {
		order := *opts.Order.Value()
		queryBuilder = queryBuilder.OrderBy(
			fmt.Sprintf(
				`"%s" %s`,
				sortBy,
				strings.ToLower(order.String()),
			),
		)
	}

	if err != nil {
		return nil, err
	}

	query, args, err := queryBuilder.ToSql()
	if err != nil {
		return nil, fmt.Errorf("invalid query on backend: %w", err)
	}

	rows, err := db.QueryContext(ctx, query, args...)
	if err != nil {
		r.logger.Error(
			"cannot get community users",
			slog.Any("err", err),
			slog.String("query", query),
			slog.Any("args", args),
		)
		return nil, err
	}

	var dbUsers []model.UsersStats
	for rows.Next() {
		var dbUser model.UsersStats

		err = rows.Scan(
			&dbUser.ID,
			&dbUser.Messages,
			&dbUser.Watched,
			&dbUser.ChannelID,
			&dbUser.UserID,
			&dbUser.UsedChannelPoints,
			&dbUser.IsMod,
			&dbUser.IsVip,
			&dbUser.IsSubscriber,
			&dbUser.Reputation,
			&dbUser.Emotes,
		)
		if err != nil {
			return nil, err
		}

		dbUsers = append(dbUsers, dbUser)
	}

	var totalStats int64
	err = r.gorm.WithContext(ctx).
		Model(&model.UsersStats{}).
		Where(`"channelId" = ? AND "messages" > 0`, opts.ChannelID).
		Count(&totalStats).Error
	if err != nil {
		return nil, err
	}

	mappedUsers := make([]gqlmodel.CommunityUser, 0, len(dbUsers))
	for _, user := range dbUsers {
		mappedUsers = append(
			mappedUsers,
			gqlmodel.CommunityUser{
				ID:                user.UserID,
				WatchedMs:         int(user.Watched),
				Messages:          int(user.Messages),
				UsedEmotes:        user.Emotes,
				UsedChannelPoints: int(user.UsedChannelPoints),
			},
		)
	}

	return &gqlmodel.CommunityUsersResponse{
		Users: mappedUsers,
		Total: int(totalStats),
	}, nil
}

// CommunityUser returns graph.CommunityUserResolver implementation.
func (r *Resolver) CommunityUser() graph.CommunityUserResolver { return &communityUserResolver{r} }

type communityUserResolver struct{ *Resolver }
