package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76

import (
	"context"

	"github.com/google/uuid"
	"github.com/twirapp/twir/apps/api-gql/internal/delivery/gql/gqlmodel"
	"github.com/twirapp/twir/apps/api-gql/internal/delivery/gql/mappers"
	"github.com/twirapp/twir/apps/api-gql/internal/services/timers"
)

// TimersCreate is the resolver for the timersCreate field.
func (r *mutationResolver) TimersCreate(ctx context.Context, opts gqlmodel.TimerCreateInput) (*gqlmodel.Timer, error) {
	dashboardId, err := r.deps.Sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return nil, err
	}

	user, err := r.deps.Sessions.GetAuthenticatedUser(ctx)
	if err != nil {
		return nil, err
	}

	responses := make([]timers.CreateResponse, 0, len(opts.Responses))
	for _, response := range opts.Responses {
		responses = append(
			responses,
			timers.CreateResponse{
				Text:       response.Text,
				IsAnnounce: response.IsAnnounce,
				Count:      response.Count,
			},
		)
	}
	timer, err := r.deps.TimersService.Create(
		ctx, timers.CreateInput{
			ChannelID:       dashboardId,
			ActorID:         user.ID,
			Name:            opts.Name,
			Enabled:         opts.Enabled,
			TimeInterval:    opts.TimeInterval,
			MessageInterval: opts.MessageInterval,
			Responses:       responses,
		},
	)
	if err != nil {
		return nil, err
	}

	converted := mappers.TimerEntityToGql(timer)
	return &converted, nil
}

// TimersCreateMany is the resolver for the timersCreateMany field.
func (r *mutationResolver) TimersCreateMany(ctx context.Context, opts []gqlmodel.TimerCreateInput) (bool, error) {
	dashboardId, err := r.deps.Sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return false, err
	}

	user, err := r.deps.Sessions.GetAuthenticatedUser(ctx)
	if err != nil {
		return false, err
	}

	inputs := make([]timers.CreateInput, 0, len(opts))
	for _, opt := range opts {
		responses := make([]timers.CreateResponse, 0, len(opt.Responses))
		for _, response := range opt.Responses {
			responses = append(
				responses,
				timers.CreateResponse{
					Text:       response.Text,
					IsAnnounce: response.IsAnnounce,
				},
			)
		}

		inputs = append(
			inputs,
			timers.CreateInput{
				ChannelID:       dashboardId,
				ActorID:         user.ID,
				Name:            opt.Name,
				Enabled:         opt.Enabled,
				TimeInterval:    opt.TimeInterval,
				MessageInterval: opt.MessageInterval,
				Responses:       responses,
			},
		)
	}

	return r.deps.TimersService.CreateMany(ctx, inputs)
}

// TimersUpdate is the resolver for the timersUpdate field.
func (r *mutationResolver) TimersUpdate(ctx context.Context, id uuid.UUID, opts gqlmodel.TimerUpdateInput) (*gqlmodel.Timer, error) {
	dashboardId, err := r.deps.Sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return nil, err
	}

	user, err := r.deps.Sessions.GetAuthenticatedUser(ctx)
	if err != nil {
		return nil, err
	}

	responses := make([]timers.CreateResponse, 0, len(opts.Responses.Value()))
	for _, response := range opts.Responses.Value() {
		responses = append(
			responses,
			timers.CreateResponse{
				Text:       response.Text,
				IsAnnounce: response.IsAnnounce,
				Count:      response.Count,
			},
		)
	}

	timer, err := r.deps.TimersService.Update(
		ctx,
		timers.UpdateInput{
			ChannelID:       dashboardId,
			ActorID:         user.ID,
			ID:              id,
			Name:            opts.Name.Value(),
			Enabled:         opts.Enabled.Value(),
			TimeInterval:    opts.TimeInterval.Value(),
			MessageInterval: opts.MessageInterval.Value(),
			Responses:       responses,
		},
	)
	if err != nil {
		return nil, err
	}

	converted := mappers.TimerEntityToGql(timer)
	return &converted, nil
}

// TimersRemove is the resolver for the timersRemove field.
func (r *mutationResolver) TimersRemove(ctx context.Context, id uuid.UUID) (bool, error) {
	dashboardId, err := r.deps.Sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return false, err
	}

	user, err := r.deps.Sessions.GetAuthenticatedUser(ctx)
	if err != nil {
		return false, err
	}

	err = r.deps.TimersService.Delete(ctx, id, dashboardId, user.ID)
	if err != nil {
		return false, err
	}

	return true, nil
}

// Timers is the resolver for the timers field.
func (r *queryResolver) Timers(ctx context.Context) ([]gqlmodel.Timer, error) {
	dashboardId, err := r.deps.Sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return nil, err
	}

	channelTimers, err := r.deps.TimersService.GetAllByChannelID(ctx, dashboardId)
	if err != nil {
		return nil, err
	}

	converted := make([]gqlmodel.Timer, 0, len(channelTimers))
	for _, timer := range channelTimers {
		converted = append(converted, mappers.TimerEntityToGql(timer))
	}

	return converted, nil
}
