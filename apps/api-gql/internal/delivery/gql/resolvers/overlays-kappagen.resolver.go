package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76

import (
	"context"
	"fmt"

	"github.com/goccy/go-json"
	model "github.com/satont/twir/libs/gomodels"
	"github.com/twirapp/twir/apps/api-gql/internal/delivery/gql/dataloader"
	"github.com/twirapp/twir/apps/api-gql/internal/delivery/gql/gqlmodel"
	"github.com/twirapp/twir/apps/api-gql/internal/delivery/gql/graph"
	"github.com/twirapp/twir/apps/api-gql/internal/delivery/gql/mappers"
	"github.com/twirapp/twir/apps/api-gql/internal/entity"
	"github.com/twirapp/twir/apps/api-gql/internal/services/overlays/kappagen"
	"github.com/twirapp/twir/libs/bus-core/api"
)

// Channel is the resolver for the channel field.
func (r *kappagenOverlayResolver) Channel(ctx context.Context, obj *gqlmodel.KappagenOverlay) (*gqlmodel.TwirUserTwitchInfo, error) {
	return dataloader.GetHelixUserById(ctx, obj.ChannelID)
}

// Channel is the resolver for the channel field.
func (r *kappagenTriggerPayloadResolver) Channel(ctx context.Context, obj *gqlmodel.KappagenTriggerPayload) (*gqlmodel.TwirUserTwitchInfo, error) {
	return dataloader.GetHelixUserById(ctx, obj.ChannelID)
}

// OverlaysKappagenUpdate is the resolver for the overlaysKappagenUpdate field.
func (r *mutationResolver) OverlaysKappagenUpdate(ctx context.Context, input gqlmodel.KappagenUpdateInput) (*gqlmodel.KappagenOverlay, error) {
	dashboardID, err := r.deps.Sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return nil, err
	}

	animations := make([]entity.KappagenOverlayAnimationsSettings, 0, len(input.Animations))
	for _, a := range input.Animations {
		animationStyle, err := mappers.MapGqlKappagenAnimationStyleToEntity(a.Style)
		if err != nil {
			return nil, err
		}

		prefs := &entity.KappagenOverlayAnimationsPrefsSettings{}
		if a.Prefs.IsSet() && a.Prefs.Value() != nil {
			if a.Prefs.Value().Size.IsSet() {
				prefs.Size = a.Prefs.Value().Size.Value()
			}

			if a.Prefs.Value().Center.IsSet() {
				prefs.Center = a.Prefs.Value().Center.Value()
			}

			if a.Prefs.Value().Speed.IsSet() {
				prefs.Speed = a.Prefs.Value().Speed.Value()
			}

			if a.Prefs.Value().Faces.IsSet() {
				prefs.Faces = a.Prefs.Value().Faces.Value()
			}

			if a.Prefs.Value().Message.IsSet() {
				prefs.Message = append([]string{}, a.Prefs.Value().Message.Value()...)
			}
		}

		var count *int
		if a.Count.IsSet() {
			count = a.Count.Value()
		}

		animations = append(
			animations, entity.KappagenOverlayAnimationsSettings{
				Style:   animationStyle,
				Prefs:   prefs,
				Count:   count,
				Enabled: a.Enabled,
			},
		)
	}

	events := make([]entity.KappagenOverlayEvent, 0, len(input.Events))
	for _, e := range input.Events {
		events = append(
			events, entity.KappagenOverlayEvent{
				Event:              entity.EventType(e.Event),
				DisabledAnimations: e.DisabledAnimations,
				Enabled:            e.Enabled,
			},
		)
	}

	updateInput := entity.KappagenOverlaySettings{
		EnableSpawn:    input.EnableSpawn,
		ExcludedEmotes: input.ExcludedEmotes,
		EnableRave:     input.EnableRave,
		Animation: entity.KappagenOverlayAnimationSettings{
			FadeIn:  input.Animation.FadeIn,
			FadeOut: input.Animation.FadeOut,
			ZoomIn:  input.Animation.ZoomIn,
			ZoomOut: input.Animation.ZoomOut,
		},
		Animations: animations,
		Emotes: entity.KappagenOverlayEmotesSettings{
			Time:           input.Emotes.Time,
			Max:            input.Emotes.Max,
			Queue:          input.Emotes.Queue,
			FfzEnabled:     input.Emotes.FfzEnabled,
			BttvEnabled:    input.Emotes.BttvEnabled,
			SevenTvEnabled: input.Emotes.SevenTvEnabled,
			EmojiStyle:     mappers.MapGqlKappagenEmoteStyleToEntity(input.Emotes.EmojiStyle),
		},
		Size: entity.KappagenOverlaySizeSettings{
			RatioNormal: input.Size.RationNormal,
			RatioSmall:  input.Size.RationSmall,
			Min:         input.Size.Min,
			Max:         input.Size.Max,
		},
		Events: events,
	}

	// Update the overlay
	updatedOverlay, err := r.deps.KappagenService.Update(
		ctx, kappagen.UpdateInput{
			ChannelID: dashboardID,
			Settings:  updateInput,
		},
	)
	if err != nil {
		return nil, fmt.Errorf("failed to update kappagen overlay: %w", err)
	}

	converted := mappers.MapKappagenEntityToGQL(updatedOverlay)
	return &converted, nil
}

// OverlaysKappagen is the resolver for the overlaysKappagen field.
func (r *queryResolver) OverlaysKappagen(ctx context.Context) (*gqlmodel.KappagenOverlay, error) {
	dashboardID, err := r.deps.Sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return nil, err
	}

	overlay, err := r.deps.KappagenService.GetOrCreate(ctx, dashboardID)
	if err != nil {
		return nil, fmt.Errorf("failed to get kappagen overlay: %w", err)
	}

	converted := mappers.MapKappagenEntityToGQL(overlay)

	return &converted, nil
}

// OverlaysKappagenAvailableAnimations is the resolver for the overlaysKappagenAvailableAnimations field.
func (r *queryResolver) OverlaysKappagenAvailableAnimations(ctx context.Context) ([]string, error) {
	animations := r.deps.KappagenService.GetAvailableAnimations()
	return animations, nil
}

// OverlaysKappagen is the resolver for the overlaysKappagen field.
func (r *subscriptionResolver) OverlaysKappagen(ctx context.Context, apiKey string) (<-chan *gqlmodel.KappagenOverlay, error) {
	user := model.Users{}
	if err := r.deps.Gorm.Where(`"apiKey" = ?`, apiKey).First(&user).Error; err != nil {
		return nil, fmt.Errorf("failed to get user: %w", err)
	}

	wsRouterSub, err := r.deps.WsRouter.Subscribe([]string{kappagen.CreateSettingsSubscriptionKey(user.ID)})
	if err != nil {
		return nil, err
	}

	chann := make(chan *gqlmodel.KappagenOverlay, 1)

	settings, err := r.deps.KappagenService.GetOrCreate(ctx, user.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to get kappagen overlay: %w", err)
	}

	converted := mappers.MapKappagenEntityToGQL(settings)
	chann <- &converted

	go func() {
		defer func() {
			wsRouterSub.Unsubscribe()
			close(chann)
		}()

		for {
			select {
			case <-ctx.Done():
				return
			case data := <-wsRouterSub.GetChannel():
				var newSettings entity.KappagenOverlay
				if err := json.Unmarshal(data, &newSettings); err != nil {
					panic(err)
				}

				newSettingsConverted := mappers.MapKappagenEntityToGQL(newSettings)

				chann <- &newSettingsConverted
			}
		}
	}()

	return chann, nil
}

// OverlaysKappagenTrigger is the resolver for the overlaysKappagenTrigger field.
func (r *subscriptionResolver) OverlaysKappagenTrigger(ctx context.Context, apiKey string) (<-chan *gqlmodel.KappagenTriggerPayload, error) {
	user := model.Users{}
	if err := r.deps.Gorm.Where(`"apiKey" = ?`, apiKey).First(&user).Error; err != nil {
		return nil, fmt.Errorf("failed to get user: %w", err)
	}
	wsRouterSub, err := r.deps.WsRouter.Subscribe([]string{kappagen.CreateTriggerSubscriptionKey(user.ID)})
	if err != nil {
		return nil, err
	}

	chann := make(chan *gqlmodel.KappagenTriggerPayload, 1)

	go func() {
		defer func() {
			wsRouterSub.Unsubscribe()
			close(chann)
		}()

		for {
			select {
			case <-ctx.Done():
				return
			case data := <-wsRouterSub.GetChannel():
				var msg api.TriggerKappagenMessage
				if err := json.Unmarshal(data, &msg); err != nil {
					panic(err)
				}

				emotes := make([]gqlmodel.KappagenTriggerRequestEmote, 0, len(msg.Emotes))
				for _, e := range msg.Emotes {
					emotes = append(
						emotes, gqlmodel.KappagenTriggerRequestEmote{
							ID:        e.Id,
							Positions: e.Positions,
						},
					)
				}

				chann <- &gqlmodel.KappagenTriggerPayload{
					Text:      msg.Text,
					Emotes:    emotes,
					ChannelID: msg.ChannelId,
				}
			}
		}
	}()

	return chann, nil
}

// KappagenOverlay returns graph.KappagenOverlayResolver implementation.
func (r *Resolver) KappagenOverlay() graph.KappagenOverlayResolver {
	return &kappagenOverlayResolver{r}
}

// KappagenTriggerPayload returns graph.KappagenTriggerPayloadResolver implementation.
func (r *Resolver) KappagenTriggerPayload() graph.KappagenTriggerPayloadResolver {
	return &kappagenTriggerPayloadResolver{r}
}

type kappagenOverlayResolver struct{ *Resolver }
type kappagenTriggerPayloadResolver struct{ *Resolver }
