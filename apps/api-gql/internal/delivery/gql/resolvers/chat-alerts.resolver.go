package resolvers

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"

	jsonpatch "github.com/evanphx/json-patch/v5"
	"github.com/google/uuid"
	"github.com/samber/lo"
	"github.com/twirapp/twir/apps/api-gql/internal/delivery/gql/gqlmodel"
	"github.com/twirapp/twir/apps/api-gql/internal/delivery/gql/mappers"
	"github.com/twirapp/twir/libs/audit"
	model "github.com/twirapp/twir/libs/gomodels"
	"github.com/twirapp/twir/libs/logger"
	"github.com/twirapp/twir/libs/utils"
	"gorm.io/gorm"
)

// UpdateChatAlerts is the resolver for the updateChatAlerts field.
func (r *mutationResolver) UpdateChatAlerts(ctx context.Context, input gqlmodel.ChatAlertsInput) (*gqlmodel.ChatAlerts, error) {
	dashboardId, err := r.deps.Sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return nil, err
	}

	user, err := r.deps.Sessions.GetAuthenticatedUserModel(ctx)
	if err != nil {
		return nil, err
	}

	// Check plan limits for total messages count
	plan, err := r.deps.PlansRepository.GetByChannelID(ctx, dashboardId)
	if err != nil {
		return nil, fmt.Errorf("failed to get plan: %w", err)
	}
	if plan.IsNil() {
		return nil, fmt.Errorf("plan not found for channel")
	}

	if input.Followers.Value() != nil && len(input.Followers.Value().Messages.Value()) > plan.MaxChatAlertsMessages {
		return nil, fmt.Errorf("you can have only %v messages across chat alerts", plan.MaxChatAlertsMessages)
	}
	if input.Raids.Value() != nil && len(input.Raids.Value().Messages.Value()) > plan.MaxChatAlertsMessages {
		return nil, fmt.Errorf("you can have only %v messages across chat alerts", plan.MaxChatAlertsMessages)
	}
	if input.Donations.Value() != nil && len(input.Donations.Value().Messages.Value()) > plan.MaxChatAlertsMessages {
		return nil, fmt.Errorf("you can have only %v messages across chat alerts", plan.MaxChatAlertsMessages)
	}
	if input.Subscribers.Value() != nil && len(input.Subscribers.Value().Messages.Value()) > plan.MaxChatAlertsMessages {
		return nil, fmt.Errorf("you can have only %v messages across chat alerts", plan.MaxChatAlertsMessages)
	}
	if input.Cheers.Value() != nil && len(input.Cheers.Value().Messages.Value()) > plan.MaxChatAlertsMessages {
		return nil, fmt.Errorf("you can have only %v messages across chat alerts", plan.MaxChatAlertsMessages)
	}
	if input.Redemptions.Value() != nil && len(input.Redemptions.Value().Messages.Value()) > plan.MaxChatAlertsMessages {
		return nil, fmt.Errorf("you can have only %v messages across chat alerts", plan.MaxChatAlertsMessages)
	}
	if input.FirstUserMessage.Value() != nil && len(input.FirstUserMessage.Value().Messages.Value()) > plan.MaxChatAlertsMessages {
		return nil, fmt.Errorf("you can have only %v messages across chat alerts", plan.MaxChatAlertsMessages)
	}
	if input.StreamOnline.Value() != nil && len(input.StreamOnline.Value().Messages.Value()) > plan.MaxChatAlertsMessages {
		return nil, fmt.Errorf("you can have only %v messages across chat alerts", plan.MaxChatAlertsMessages)
	}
	if input.StreamOffline.Value() != nil && len(input.StreamOffline.Value().Messages.Value()) > plan.MaxChatAlertsMessages {
		return nil, fmt.Errorf("you can have only %v messages across chat alerts", plan.MaxChatAlertsMessages)
	}
	if input.ChatCleared.Value() != nil && len(input.ChatCleared.Value().Messages.Value()) > plan.MaxChatAlertsMessages {
		return nil, fmt.Errorf("you can have only %v messages across chat alerts", plan.MaxChatAlertsMessages)
	}
	if input.Ban.Value() != nil && len(input.Ban.Value().Messages.Value()) > plan.MaxChatAlertsMessages {
		return nil, fmt.Errorf("you can have only %v messages across chat alerts", plan.MaxChatAlertsMessages)
	}
	if input.UnbanRequestCreate.Value() != nil && len(input.UnbanRequestCreate.Value().Messages.Value()) > plan.MaxChatAlertsMessages {
		return nil, fmt.Errorf("you can have only %v messages across chat alerts", plan.MaxChatAlertsMessages)
	}
	if input.UnbanRequestResolve.Value() != nil && len(input.UnbanRequestResolve.Value().Messages.Value()) > plan.MaxChatAlertsMessages {
		return nil, fmt.Errorf("you can have only %v messages across chat alerts", plan.MaxChatAlertsMessages)
	}
	if input.MessageDelete.Value() != nil && len(input.MessageDelete.Value().Messages.Value()) > plan.MaxChatAlertsMessages {
		return nil, fmt.Errorf("you can have only %v messages across chat alerts", plan.MaxChatAlertsMessages)
	}

	entity := model.ChannelModulesSettings{}
	if err := r.deps.Gorm.
		WithContext(ctx).
		Where(
			`"channelId" = ? AND "userId" IS NULL AND type = 'chat_alerts'`,
			dashboardId,
		).First(&entity).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			entity = model.ChannelModulesSettings{
				ID:        uuid.NewString(),
				ChannelId: dashboardId,
				Settings:  []byte("{}"),
				Type:      "chat_alerts",
			}
		} else {
			return nil, err
		}
	}
	var entityCopy model.ChannelModulesSettings
	if err := utils.DeepCopy(&entity, &entityCopy); err != nil {
		return nil, err
	}

	inputBytes, err := json.Marshal(input)
	if err != nil {
		return nil, err
	}

	patch, err := jsonpatch.MergePatch(entity.Settings, inputBytes)
	if err != nil {
		return nil, err
	}

	entity.Settings, err = jsonpatch.MergePatch(entity.Settings, patch)
	if err != nil {
		return nil, err
	}

	if err := r.deps.Gorm.
		WithContext(ctx).
		Save(&entity).Error; err != nil {
		return nil, err
	}

	_ = r.deps.AuditRecorder.RecordUpdateOperation(
		ctx,
		audit.UpdateOperation{
			Metadata: audit.OperationMetadata{
				System:    mappers.AuditSystemToTableName(gqlmodel.AuditLogSystemChannelsChatAlerts),
				ActorID:   lo.ToPtr(user.ID),
				ChannelID: lo.ToPtr(dashboardId),
				ObjectID:  &entity.ID,
			},
			NewValue: entity,
			OldValue: entityCopy,
		},
	)

	if err := r.deps.ChatAlertsCache.Invalidate(ctx, dashboardId); err != nil {
		r.deps.Logger.Error("failed to invalidate chat alerts cache", logger.Error(err))
	}

	return r.Query().ChatAlerts(ctx)
}

// ChatAlerts is the resolver for the chatAlerts field.
func (r *queryResolver) ChatAlerts(ctx context.Context) (*gqlmodel.ChatAlerts, error) {
	dashboardId, err := r.deps.Sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return nil, err
	}

	entity := model.ChannelModulesSettings{}
	if err := r.deps.Gorm.
		WithContext(ctx).
		Where(
			`"channelId" = ? AND "userId" IS NULL AND type = 'chat_alerts'`,
			dashboardId,
		).First(&entity).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return &gqlmodel.ChatAlerts{}, nil
		}
		return nil, err
	}

	parsedSettings := gqlmodel.ChatAlerts{}
	if err := json.Unmarshal(entity.Settings, &parsedSettings); err != nil {
		return nil, err
	}

	return &parsedSettings, nil
}
