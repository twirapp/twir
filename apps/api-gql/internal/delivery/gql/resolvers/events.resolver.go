package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.57

import (
	"context"
	"fmt"

	"github.com/twirapp/twir/apps/api-gql/internal/delivery/gql/gqlmodel"
	"github.com/twirapp/twir/apps/api-gql/internal/delivery/gql/mappers"
	"github.com/twirapp/twir/apps/api-gql/internal/services/events"
)

// EventCreate is the resolver for the eventCreate field.
func (r *mutationResolver) EventCreate(
	ctx context.Context,
	input gqlmodel.EventCreateInput,
) (*gqlmodel.Event, error) {
	dashboardID, err := r.deps.Sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return nil, err
	}

	operations := make([]events.OperationInput, 0, len(input.Operations))
	for _, op := range input.Operations {
		filters := make([]events.OperationFilterInput, 0, len(op.Filters))
		for _, f := range op.Filters {
			filters = append(
				filters, events.OperationFilterInput{
					Type:  f.Type,
					Left:  f.Left,
					Right: f.Right,
				},
			)
		}

		operations = append(
			operations, events.OperationInput{
				Type:           op.Type,
				Input:          op.Input.Value(),
				Delay:          op.Delay,
				Repeat:         op.Repeat,
				UseAnnounce:    op.UseAnnounce,
				TimeoutTime:    op.TimeoutTime,
				TimeoutMessage: op.TimeoutMessage.Value(),
				Target:         op.Target.Value(),
				Enabled:        op.Enabled,
				Filters:        filters,
			},
		)
	}

	event, err := r.deps.EventsService.Create(
		ctx, events.CreateInput{
			ChannelID:   dashboardID,
			Type:        input.Type,
			RewardID:    input.RewardID.Value(),
			CommandID:   input.CommandID.Value(),
			KeywordID:   input.KeywordID.Value(),
			Description: input.Description,
			Enabled:     input.Enabled,
			OnlineOnly:  input.OnlineOnly,
			Operations:  operations,
		},
	)
	if err != nil {
		return nil, err
	}

	converted := mappers.MapEventToGQL(event)
	return &converted, nil
}

// EventUpdate is the resolver for the eventUpdate field.
func (r *mutationResolver) EventUpdate(
	ctx context.Context,
	id string,
	input gqlmodel.EventUpdateInput,
) (*gqlmodel.Event, error) {
	var operations *[]events.OperationInput

	ops := make([]events.OperationInput, 0, len(input.Operations.Value()))
	for _, op := range input.Operations.Value() {
		filters := make([]events.OperationFilterInput, 0, len(op.Filters))
		for _, f := range op.Filters {
			filters = append(
				filters, events.OperationFilterInput{
					Type:  f.Type,
					Left:  f.Left,
					Right: f.Right,
				},
			)
		}

		ops = append(
			ops, events.OperationInput{
				Type:           op.Type,
				Input:          op.Input.Value(),
				Delay:          op.Delay,
				Repeat:         op.Repeat,
				UseAnnounce:    op.UseAnnounce,
				TimeoutTime:    op.TimeoutTime,
				TimeoutMessage: op.TimeoutMessage.Value(),
				Target:         op.Target.Value(),
				Enabled:        op.Enabled,
				Filters:        filters,
			},
		)
	}
	operations = &ops

	event, err := r.deps.EventsService.Update(
		ctx, id, events.UpdateInput{
			Type:        input.Type.Value(),
			RewardID:    input.RewardID.Value(),
			CommandID:   input.CommandID.Value(),
			KeywordID:   input.KeywordID.Value(),
			Description: input.Description.Value(),
			Enabled:     input.Enabled.Value(),
			OnlineOnly:  input.OnlineOnly.Value(),
			Operations:  operations,
		},
	)
	if err != nil {
		return nil, err
	}

	converted := mappers.MapEventToGQL(event)
	return &converted, nil
}

// EventDelete is the resolver for the eventDelete field.
func (r *mutationResolver) EventDelete(ctx context.Context, id string) (bool, error) {
	err := r.deps.EventsService.Delete(ctx, id)
	if err != nil {
		return false, err
	}

	return true, nil
}

// EventEnableOrDisable is the resolver for the eventEnableOrDisable field.
func (r *mutationResolver) EventEnableOrDisable(
	ctx context.Context,
	id string,
	enabled bool,
) (*gqlmodel.Event, error) {
	event, err := r.deps.EventsService.Update(
		ctx, id, events.UpdateInput{
			Enabled: &enabled,
		},
	)
	if err != nil {
		return nil, err
	}

	converted := mappers.MapEventToGQL(event)
	return &converted, nil
}

// Events is the resolver for the events field.
func (r *queryResolver) Events(ctx context.Context) ([]gqlmodel.Event, error) {
	dashboardID, err := r.deps.Sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return nil, err
	}

	eventsData, err := r.deps.EventsService.GetAll(ctx, dashboardID)
	if err != nil {
		return nil, err
	}

	result := make([]gqlmodel.Event, 0, len(eventsData))
	for _, event := range eventsData {
		result = append(result, mappers.MapEventToGQL(event))
	}

	return result, nil
}

// EventByID is the resolver for the eventById field.
func (r *queryResolver) EventByID(ctx context.Context, id string) (*gqlmodel.Event, error) {
	panic(fmt.Errorf("not implemented: EventByID - eventById"))
}
