package resolvers

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"

	data_loader "github.com/twirapp/twir/apps/api-gql/internal/delivery/gql/dataloader"
	"github.com/twirapp/twir/apps/api-gql/internal/delivery/gql/gqlmodel"
	"github.com/twirapp/twir/apps/api-gql/internal/delivery/gql/graph"
	"github.com/twirapp/twir/apps/api-gql/internal/entity"
	channelsemotesusages "github.com/twirapp/twir/apps/api-gql/internal/services/channels_emotes_usages"
	"github.com/twirapp/twir/libs/repositories/channels_emotes_usages"
	"golang.org/x/sync/errgroup"
)

// TwitchProfile is the resolver for the twitchProfile field.
func (r *emoteStatisticTopUserResolver) TwitchProfile(ctx context.Context, obj *gqlmodel.EmoteStatisticTopUser) (*gqlmodel.TwirUserTwitchInfo, error) {
	return data_loader.GetHelixUserById(ctx, obj.UserID)
}

// TwitchProfile is the resolver for the twitchProfile field.
func (r *emoteStatisticUserUsageResolver) TwitchProfile(ctx context.Context, obj *gqlmodel.EmoteStatisticUserUsage) (*gqlmodel.TwirUserTwitchInfo, error) {
	return data_loader.GetHelixUserById(ctx, obj.UserID)
}

// EmotesStatistics is the resolver for the emotesStatistics field.
func (r *queryResolver) EmotesStatistics(ctx context.Context, opts gqlmodel.EmotesStatisticsOpts) (*gqlmodel.EmotesStatisticResponse, error) {
	dashboardId, err := r.deps.Sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return nil, err
	}

	statisticInput := channelsemotesusages.GetEmotesStatisticsInput{
		ChannelID:   dashboardId,
		EmoteSearch: opts.Search.Value(),
		Page:        0,
		PerPage:     0,
	}

	if opts.Page.IsSet() {
		statisticInput.Page = *opts.Page.Value()
	}

	if opts.PerPage.IsSet() {
		statisticInput.PerPage = *opts.PerPage.Value()
	}

	statistic, err := r.deps.ChannelsEmotesUsagesService.GetEmotesStatistics(ctx, statisticInput)
	if err != nil {
		return nil, err
	}

	emotesNames := make([]string, len(statistic))
	for i, stat := range statistic {
		emotesNames[i] = stat.EmoteName
	}

	emoteRange := channels_emotes_usages.EmoteStatisticRangeLastDay
	if opts.GraphicRange.IsSet() {
		switch *opts.GraphicRange.Value() {
		case gqlmodel.EmoteStatisticRangeLastDay:
			emoteRange = channels_emotes_usages.EmoteStatisticRangeLastDay
		case gqlmodel.EmoteStatisticRangeLastWeek:
			emoteRange = channels_emotes_usages.EmoteStatisticRangeLastWeek
		case gqlmodel.EmoteStatisticRangeLastMonth:
			emoteRange = channels_emotes_usages.EmoteStatisticRangeLastMonth
		case gqlmodel.EmoteStatisticRangeLastThreeMonth:
			emoteRange = channels_emotes_usages.EmoteStatisticRangeLastThreeMonth
		case gqlmodel.EmoteStatisticRangeLastYear:
			emoteRange = channels_emotes_usages.EmoteStatisticRangeLastYear
		}
	}

	emotesUsages, err := r.deps.ChannelsEmotesUsagesService.GetEmotesRanges(
		ctx,
		dashboardId,
		emotesNames,
		emoteRange,
	)
	if err != nil {
		return nil, err
	}

	models := make([]gqlmodel.EmotesStatistic, 0, len(statistic))
	for _, s := range statistic {
		graphicUsages := emotesUsages[s.EmoteName]
		graphicUsage := make([]gqlmodel.EmoteStatisticUsage, len(graphicUsages))
		for i, usage := range graphicUsages {
			graphicUsage[i] = gqlmodel.EmoteStatisticUsage{
				Count:     int(usage.Count),
				Timestamp: int(usage.TimeStamp),
			}
		}

		models = append(
			models,
			gqlmodel.EmotesStatistic{
				EmoteName:         s.EmoteName,
				TotalUsages:       int(s.TotalUsages),
				LastUsedTimestamp: int(s.LastUsedTimestamp),
				GraphicUsages:     graphicUsage,
			},
		)
	}

	totalCount, err := r.deps.ChannelsEmotesUsagesService.Count(
		ctx,
		channelsemotesusages.CountInput{
			ChannelID: &dashboardId,
		},
	)
	if err != nil {
		return nil, err
	}

	return &gqlmodel.EmotesStatisticResponse{
		Emotes: models,
		Total:  int(totalCount),
	}, nil
}

// EmotesStatisticEmoteDetailedInformation is the resolver for the emotesStatisticEmoteDetailedInformation field.
func (r *queryResolver) EmotesStatisticEmoteDetailedInformation(ctx context.Context, opts gqlmodel.EmotesStatisticEmoteDetailedOpts) (*gqlmodel.EmotesStatisticEmoteDetailedResponse, error) {
	if opts.EmoteName == "" {
		return nil, nil
	}

	dashboardId, err := r.deps.Sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return nil, err
	}

	emoteRange := channels_emotes_usages.EmoteStatisticRangeLastDay
	switch opts.Range {
	case gqlmodel.EmoteStatisticRangeLastDay:
		emoteRange = channels_emotes_usages.EmoteStatisticRangeLastDay
	case gqlmodel.EmoteStatisticRangeLastWeek:
		emoteRange = channels_emotes_usages.EmoteStatisticRangeLastWeek
	case gqlmodel.EmoteStatisticRangeLastMonth:
		emoteRange = channels_emotes_usages.EmoteStatisticRangeLastMonth
	case gqlmodel.EmoteStatisticRangeLastThreeMonth:
		emoteRange = channels_emotes_usages.EmoteStatisticRangeLastThreeMonth
	case gqlmodel.EmoteStatisticRangeLastYear:
		emoteRange = channels_emotes_usages.EmoteStatisticRangeLastYear
	}

	wg, wgCtx := errgroup.WithContext(ctx)

	var emotesStatistic []entity.EmoteStatistic
	var ranges []entity.EmoteRange

	wg.Go(
		func() error {
			s, err := r.deps.ChannelsEmotesUsagesService.GetEmotesStatistics(
				wgCtx,
				channelsemotesusages.GetEmotesStatisticsInput{
					ChannelID:   dashboardId,
					EmoteSearch: &opts.EmoteName,
					Page:        0,
					PerPage:     1,
				},
			)
			if err != nil {
				return err
			}

			emotesStatistic = s

			return nil
		},
	)

	wg.Go(
		func() error {
			emotesUsages, err := r.deps.ChannelsEmotesUsagesService.GetEmotesRanges(
				wgCtx,
				dashboardId,
				[]string{opts.EmoteName},
				emoteRange,
			)
			if err != nil {
				return err
			}

			ranges = emotesUsages[opts.EmoteName]
			return nil
		},
	)

	var (
		usagesByUsersPage    int
		usagesByUsersPerPage int
		topUsersPage         int
		topUsersPerPage      int
	)

	if opts.UsagesByUsersPage.IsSet() {
		usagesByUsersPage = *opts.UsagesByUsersPage.Value()
	}

	if opts.UsagesByUsersPerPage.IsSet() {
		usagesByUsersPerPage = *opts.UsagesByUsersPerPage.Value()
	}

	if opts.TopUsersPage.IsSet() {
		topUsersPage = *opts.TopUsersPage.Value()
	}

	if opts.TopUsersPerPage.IsSet() {
		topUsersPerPage = *opts.TopUsersPerPage.Value()
	}

	var topUsers []entity.EmoteStatisticTopUser
	var topUsersTotal uint64
	var usagesHistory []entity.EmoteStatisticUserUsage
	var usagesHistoryTotal uint64

	wg.Go(
		func() error {
			u, total, err := r.deps.ChannelsEmotesUsagesService.GetChannelEmoteUsageTopUsers(
				wgCtx,
				channelsemotesusages.GetChannelEmoteUsageHistoryInput{
					ChannelID: dashboardId,
					EmoteName: opts.EmoteName,
					Page:      topUsersPage,
					PerPage:   topUsersPerPage,
				},
			)
			if err != nil {
				return err
			}

			topUsers = u
			topUsersTotal = total

			return nil
		},
	)

	wg.Go(
		func() error {
			u, total, err := r.deps.ChannelsEmotesUsagesService.GetChannelEmoteUsageHistory(
				wgCtx,
				channelsemotesusages.GetChannelEmoteUsageHistoryInput{
					ChannelID: dashboardId,
					EmoteName: opts.EmoteName,
					Page:      usagesByUsersPage,
					PerPage:   usagesByUsersPerPage,
				},
			)
			if err != nil {
				return err
			}

			usagesHistory = u
			usagesHistoryTotal = total

			return nil
		},
	)

	if err := wg.Wait(); err != nil {
		return nil, err
	}

	graphicUsages := make([]gqlmodel.EmoteStatisticUsage, len(ranges))
	for i, usage := range ranges {
		graphicUsages[i] = gqlmodel.EmoteStatisticUsage{
			Count:     int(usage.Count),
			Timestamp: int(usage.TimeStamp),
		}
	}

	topUsersGql := make([]gqlmodel.EmoteStatisticTopUser, len(topUsers))
	for i, user := range topUsers {
		topUsersGql[i] = gqlmodel.EmoteStatisticTopUser{
			UserID: user.UserID,
			Count:  user.Count,
		}
	}

	usagesHistoryGql := make([]gqlmodel.EmoteStatisticUserUsage, len(usagesHistory))
	for i, usage := range usagesHistory {
		usagesHistoryGql[i] = gqlmodel.EmoteStatisticUserUsage{
			UserID: usage.UserID,
			Date:   usage.Date,
		}
	}

	return &gqlmodel.EmotesStatisticEmoteDetailedResponse{
		EmoteName:          opts.EmoteName,
		TotalUsages:        int(emotesStatistic[0].TotalUsages),
		LastUsedTimestamp:  int(emotesStatistic[0].LastUsedTimestamp),
		GraphicUsages:      graphicUsages,
		UsagesHistory:      usagesHistoryGql,
		UsagesByUsersTotal: int(usagesHistoryTotal),
		TopUsers:           topUsersGql,
		TopUsersTotal:      int(topUsersTotal),
	}, nil
}

// EmoteStatisticTopUser returns graph.EmoteStatisticTopUserResolver implementation.
func (r *Resolver) EmoteStatisticTopUser() graph.EmoteStatisticTopUserResolver {
	return &emoteStatisticTopUserResolver{r}
}

// EmoteStatisticUserUsage returns graph.EmoteStatisticUserUsageResolver implementation.
func (r *Resolver) EmoteStatisticUserUsage() graph.EmoteStatisticUserUsageResolver {
	return &emoteStatisticUserUsageResolver{r}
}

type emoteStatisticTopUserResolver struct{ *Resolver }
type emoteStatisticUserUsageResolver struct{ *Resolver }
