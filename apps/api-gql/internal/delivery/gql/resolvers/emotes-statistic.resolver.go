package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.57

import (
	"context"

	data_loader "github.com/twirapp/twir/apps/api-gql/internal/delivery/gql/dataloader"
	"github.com/twirapp/twir/apps/api-gql/internal/delivery/gql/gqlmodel"
	"github.com/twirapp/twir/apps/api-gql/internal/delivery/gql/graph"
	channelsemotesusages "github.com/twirapp/twir/apps/api-gql/internal/services/channels_emotes_usages"
	"github.com/twirapp/twir/libs/repositories/channels_emotes_usages"
)

// TwitchProfile is the resolver for the twitchProfile field.
func (r *emoteStatisticTopUserResolver) TwitchProfile(
	ctx context.Context,
	obj *gqlmodel.EmoteStatisticTopUser,
) (*gqlmodel.TwirUserTwitchInfo, error) {
	return data_loader.GetHelixUserById(ctx, obj.UserID)
}

// TwitchProfile is the resolver for the twitchProfile field.
func (r *emoteStatisticUserUsageResolver) TwitchProfile(
	ctx context.Context,
	obj *gqlmodel.EmoteStatisticUserUsage,
) (*gqlmodel.TwirUserTwitchInfo, error) {
	return data_loader.GetHelixUserById(ctx, obj.UserID)
}

// EmotesStatistics is the resolver for the emotesStatistics field.
func (r *queryResolver) EmotesStatistics(
	ctx context.Context,
	opts gqlmodel.EmotesStatisticsOpts,
) (*gqlmodel.EmotesStatisticResponse, error) {
	dashboardId, err := r.deps.Sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return nil, err
	}

	statisticInput := channelsemotesusages.GetEmotesStatisticsInput{
		ChannelID:   dashboardId,
		EmoteSearch: opts.Search.Value(),
		Page:        0,
		PerPage:     0,
	}

	if opts.Page.IsSet() {
		statisticInput.Page = *opts.Page.Value()
	}

	if opts.PerPage.IsSet() {
		statisticInput.PerPage = *opts.PerPage.Value()
	}

	statistic, err := r.deps.ChannelsEmotesUsagesService.GetEmotesStatistics(ctx, statisticInput)
	if err != nil {
		return nil, err
	}

	emotesNames := make([]string, len(statistic))
	for i, stat := range statistic {
		emotesNames[i] = stat.EmoteName
	}

	emoteRange := channels_emotes_usages.EmoteStatisticRangeLastDay
	if opts.GraphicRange.IsSet() {
		switch *opts.GraphicRange.Value() {
		case gqlmodel.EmoteStatisticRangeLastDay:
			emoteRange = channels_emotes_usages.EmoteStatisticRangeLastDay
		case gqlmodel.EmoteStatisticRangeLastWeek:
			emoteRange = channels_emotes_usages.EmoteStatisticRangeLastWeek
		case gqlmodel.EmoteStatisticRangeLastMonth:
			emoteRange = channels_emotes_usages.EmoteStatisticRangeLastMonth
		case gqlmodel.EmoteStatisticRangeLastThreeMonth:
			emoteRange = channels_emotes_usages.EmoteStatisticRangeLastThreeMonth
		case gqlmodel.EmoteStatisticRangeLastYear:
			emoteRange = channels_emotes_usages.EmoteStatisticRangeLastYear
		}
	}

	emotesUsages, err := r.deps.ChannelsEmotesUsagesService.GetEmotesRanges(
		ctx,
		dashboardId,
		emotesNames,
		emoteRange,
	)
	if err != nil {
		return nil, err
	}

	models := make([]gqlmodel.EmotesStatistic, 0, len(statistic))
	for _, s := range statistic {
		graphicUsages := emotesUsages[s.EmoteName]
		graphicUsage := make([]gqlmodel.EmoteStatisticUsage, len(graphicUsages))
		for i, usage := range graphicUsages {
			graphicUsage[i] = gqlmodel.EmoteStatisticUsage{
				Count:     int(usage.Count),
				Timestamp: int(usage.TimeStamp),
			}
		}

		models = append(
			models,
			gqlmodel.EmotesStatistic{
				EmoteName:         s.EmoteName,
				TotalUsages:       int(s.TotalUsages),
				LastUsedTimestamp: int(s.LastUsedTimestamp),
				GraphicUsages:     graphicUsage,
			},
		)
	}

	totalCount, err := r.deps.ChannelsEmotesUsagesService.Count(
		ctx,
		channelsemotesusages.CountInput{
			ChannelID: &dashboardId,
		},
	)
	if err != nil {
		return nil, err
	}

	return &gqlmodel.EmotesStatisticResponse{
		Emotes: models,
		Total:  int(totalCount),
	}, nil
}

// EmotesStatisticEmoteDetailedInformation is the resolver for the emotesStatisticEmoteDetailedInformation field.
func (r *queryResolver) EmotesStatisticEmoteDetailedInformation(
	ctx context.Context,
	opts gqlmodel.EmotesStatisticEmoteDetailedOpts,
) (*gqlmodel.EmotesStatisticEmoteDetailedResponse, error) {
	return nil, nil
	// if opts.EmoteName == "" {
	// 	return nil, nil
	// }
	//
	// dashboardId, err := r.deps.Sessions.GetSelectedDashboard(ctx)
	// if err != nil {
	// 	return nil, err
	// }
	//
	// graphicUsages, err := r.getEmoteStatisticUsagesForRange(ctx, opts.EmoteName, opts.Range)
	// if err != nil {
	// 	return nil, err
	// }
	//
	// lastUsedEntity := &model.ChannelEmoteUsage{}
	// if err := r.deps.Gorm.
	// 	WithContext(ctx).
	// 	Where(`"channelId" = ? AND "emote" = ?`, dashboardId, opts.EmoteName).
	// 	Order(`"createdAt" DESC`).
	// 	First(lastUsedEntity).Error; err != nil {
	// 	return nil, err
	// }
	//
	// var usages int64
	// if err := r.deps.Gorm.
	// 	WithContext(ctx).
	// 	Model(&model.ChannelEmoteUsage{}).
	// 	Where(`"channelId" = ? AND "emote" = ?`, dashboardId, opts.EmoteName).
	// 	Count(&usages).Error; err != nil {
	// 	return nil, err
	// }
	//
	// var usagedByUserPage int
	// usagesByUserPerPage := 10
	// if opts.UsagesByUsersPage.IsSet() {
	// 	usagedByUserPage = *opts.UsagesByUsersPage.Value()
	// }
	// if opts.UsagesByUsersPerPage.IsSet() {
	// 	usagesByUserPerPage = *opts.UsagesByUsersPerPage.Value()
	// }
	//
	// var usagesHistoryEntities []model.ChannelEmoteUsage
	// if err := r.deps.Gorm.
	// 	WithContext(ctx).
	// 	Where(`"channelId" = ? AND "emote" = ?`, dashboardId, opts.EmoteName).
	// 	Order(`"createdAt" DESC`).
	// 	Limit(usagesByUserPerPage).
	// 	Offset(usagedByUserPage * usagesByUserPerPage).
	// 	Find(&usagesHistoryEntities).Error; err != nil {
	// 	return nil, err
	// }
	// var usagesByUsersTotalCount int64
	// if err := r.deps.Gorm.
	// 	WithContext(ctx).
	// 	Model(&model.ChannelEmoteUsage{}).
	// 	Where(`"channelId" = ? AND "emote" = ?`, dashboardId, opts.EmoteName).
	// 	Count(&usagesByUsersTotalCount).Error; err != nil {
	// 	return nil, err
	// }
	//
	// var topUsersPage int
	// topUsersPerPage := 10
	// if opts.TopUsersPage.IsSet() {
	// 	topUsersPage = *opts.TopUsersPage.Value()
	// }
	// if opts.TopUsersPerPage.IsSet() {
	// 	topUsersPerPage = *opts.TopUsersPerPage.Value()
	// }
	//
	// var topUsersEntities []emoteEntityModelWithCount
	// if err := r.deps.Gorm.
	// 	WithContext(ctx).
	// 	Where(`"channelId" = ? AND "emote" = ?`, dashboardId, opts.EmoteName).
	// 	Select(`"userId", COUNT("userId") as count`).
	// 	Group("userId").
	// 	Order("count DESC").
	// 	Limit(topUsersPerPage).
	// 	Offset(topUsersPage * topUsersPerPage).
	// 	Find(&topUsersEntities).Error; err != nil {
	// 	return nil, err
	// }
	//
	// var topUsersTotalCount int64
	// if err := r.deps.Gorm.
	// 	WithContext(ctx).
	// 	Model(&model.ChannelEmoteUsage{}).
	// 	Where(`"channelId" = ? AND "emote" = ?`, dashboardId, opts.EmoteName).
	// 	Group(`"userId"`).
	// 	Count(&topUsersTotalCount).Error; err != nil {
	// 	return nil, err
	// }
	//
	// usagesHistory := make([]gqlmodel.EmoteStatisticUserUsage, 0, len(usagesHistoryEntities))
	// for _, usage := range usagesHistoryEntities {
	// 	usagesHistory = append(
	// 		usagesHistory,
	// 		gqlmodel.EmoteStatisticUserUsage{
	// 			UserID: usage.UserID,
	// 			Date:   usage.CreatedAt,
	// 		},
	// 	)
	// }
	//
	// topUsers := make([]gqlmodel.EmoteStatisticTopUser, 0, len(topUsersEntities))
	// for _, user := range topUsersEntities {
	// 	topUsers = append(
	// 		topUsers,
	// 		gqlmodel.EmoteStatisticTopUser{
	// 			UserID: user.UserID,
	// 			Count:  user.Count,
	// 		},
	// 	)
	// }
	//
	// return &gqlmodel.EmotesStatisticEmoteDetailedResponse{
	// 	EmoteName:          opts.EmoteName,
	// 	TotalUsages:        int(usages),
	// 	LastUsedTimestamp:  int(lastUsedEntity.CreatedAt.UTC().UnixMilli()),
	// 	GraphicUsages:      graphicUsages,
	// 	UsagesHistory:      usagesHistory,
	// 	UsagesByUsersTotal: int(usagesByUsersTotalCount),
	// 	TopUsers:           topUsers,
	// 	TopUsersTotal:      int(topUsersTotalCount),
	// }, nil
}

// EmoteStatisticTopUser returns graph.EmoteStatisticTopUserResolver implementation.
func (r *Resolver) EmoteStatisticTopUser() graph.EmoteStatisticTopUserResolver {
	return &emoteStatisticTopUserResolver{r}
}

// EmoteStatisticUserUsage returns graph.EmoteStatisticUserUsageResolver implementation.
func (r *Resolver) EmoteStatisticUserUsage() graph.EmoteStatisticUserUsageResolver {
	return &emoteStatisticUserUsageResolver{r}
}

type emoteStatisticTopUserResolver struct{ *Resolver }
type emoteStatisticUserUsageResolver struct{ *Resolver }
