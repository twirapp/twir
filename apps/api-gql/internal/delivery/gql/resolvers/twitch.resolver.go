package resolvers

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"
	"fmt"

	"github.com/twirapp/twir/apps/api-gql/internal/delivery/gql/dataloader"
	"github.com/twirapp/twir/apps/api-gql/internal/delivery/gql/gqlmodel"
	"github.com/twirapp/twir/apps/api-gql/internal/delivery/gql/mappers"
	"github.com/twirapp/twir/apps/api-gql/internal/services/twitch"
)

// TwitchSetChannelInformation is the resolver for the twitchSetChannelInformation field.
func (r *mutationResolver) TwitchSetChannelInformation(ctx context.Context, categoryID *string, title *string) (bool, error) {
	dashboardID, err := r.deps.Sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return false, err
	}

	if categoryID == nil && title == nil {
		return false, fmt.Errorf("at least one of categoryId or title must be provided")
	}

	err = r.deps.TwitchService.SetChannelInformation(ctx, twitch.SetChannelInformationInput{
		ChannelID:  dashboardID,
		CategoryID: categoryID,
		Title:      title,
	})
	if err != nil {
		return false, err
	}

	return true, nil
}

// TwitchGetUserByID is the resolver for the twitchGetUserById field.
func (r *queryResolver) TwitchGetUserByID(ctx context.Context, id string) (*gqlmodel.TwirUserTwitchInfo, error) {
	if id == "" {
		return nil, fmt.Errorf("id is required")
	}

	return dataloader.GetHelixUserById(ctx, id)
}

// TwitchGetUserByName is the resolver for the twitchGetUserByName field.
func (r *queryResolver) TwitchGetUserByName(ctx context.Context, name string) (*gqlmodel.TwirUserTwitchInfo, error) {
	if name == "" {
		return nil, fmt.Errorf("name is required")
	}

	return dataloader.GetHelixUserByName(ctx, name)
}

// TwitchGetUsers is the resolver for the twitchGetUsers field.
func (r *queryResolver) TwitchGetUsers(ctx context.Context, ids []string, names []string) ([]gqlmodel.TwirUserTwitchInfo, error) {
	// Validate that at least one parameter is provided
	if (ids == nil || len(ids) == 0) && (names == nil || len(names) == 0) {
		return []gqlmodel.TwirUserTwitchInfo{}, nil
	}

	var users []*gqlmodel.TwirUserTwitchInfo

	// Get users by IDs
	if ids != nil && len(ids) > 0 {
		usersByIds, err := dataloader.GetHelixUsersByIds(ctx, ids)
		if err != nil {
			return nil, err
		}
		users = append(users, usersByIds...)
	}

	// Get users by names
	if names != nil && len(names) > 0 {
		usersByNames, err := dataloader.GetHelixUsersByName(ctx, names)
		if err != nil {
			return nil, err
		}
		users = append(users, usersByNames...)
	}

	// Remove duplicates based on ID
	seen := make(map[string]bool)
	uniqueUsers := make([]gqlmodel.TwirUserTwitchInfo, 0, len(users))
	for _, user := range users {
		if user != nil && !seen[user.ID] {
			seen[user.ID] = true
			uniqueUsers = append(uniqueUsers, *user)
		}
	}

	return uniqueUsers, nil
}

// TwitchSearchChannels is the resolver for the twitchSearchChannels field.
func (r *queryResolver) TwitchSearchChannels(ctx context.Context, query string, twirOnly *bool) (*gqlmodel.TwitchSearchChannelsResponse, error) {
	if query == "" {
		return &gqlmodel.TwitchSearchChannelsResponse{
			Channels: []gqlmodel.TwitchChannel{},
		}, nil
	}

	twirOnlyFlag := false
	if twirOnly != nil {
		twirOnlyFlag = *twirOnly
	}

	channels, err := r.deps.TwitchService.SearchChannels(
		ctx,
		twitch.SearchChannelsInput{
			Query:    query,
			TwirOnly: twirOnlyFlag,
		},
	)
	if err != nil {
		return nil, err
	}

	mappedChannels := make([]gqlmodel.TwitchChannel, 0, len(channels))
	for _, channel := range channels {
		mappedChannels = append(
			mappedChannels, gqlmodel.TwitchChannel{
				ID:              channel.ID,
				Login:           channel.BroadcasterLogin,
				DisplayName:     channel.DisplayName,
				ProfileImageURL: channel.ThumbnailURL,
				Title:           channel.Title,
				GameName:        channel.GameName,
				GameID:          channel.GameID,
				IsLive:          channel.IsLive,
			},
		)
	}

	return &gqlmodel.TwitchSearchChannelsResponse{
		Channels: mappedChannels,
	}, nil
}

// TwitchGetChannelRewards is the resolver for the twitchGetChannelRewards field.
func (r *queryResolver) TwitchGetChannelRewards(ctx context.Context, channelID *string) (*gqlmodel.TwirTwitchChannelRewardResponse, error) {
	var channelId string
	if channelID == nil {
		dashboardId, err := r.deps.Sessions.GetSelectedDashboard(ctx)
		if err != nil {
			return nil, err
		}
		channelId = dashboardId
	} else {
		channelId = *channelID
	}

	if channelId == "" {
		return nil, fmt.Errorf("channelID is required")
	}

	rewards, err := r.deps.TwitchService.GetRewardsByChannelID(ctx, channelId)
	if err != nil {
		return nil, err
	}

	mappedRewards := make([]gqlmodel.TwirTwitchChannelReward, 0, len(rewards.Rewards))
	for _, reward := range rewards.Rewards {
		mappedRewards = append(mappedRewards, mappers.TwitchCustomRewardTo(reward))
	}

	return &gqlmodel.TwirTwitchChannelRewardResponse{
		PartnerOrAffiliate: rewards.IsPartnerOrAffiliate,
		Rewards:            mappedRewards,
	}, nil
}

// TwitchGetChannelBadges is the resolver for the twitchGetChannelBadges field.
func (r *queryResolver) TwitchGetChannelBadges(ctx context.Context, channelID *string) (*gqlmodel.TwirTwitchChannelBadgeResponse, error) {
	var userId string
	if channelID != nil {
		userId = *channelID
	} else {
		dashboardId, err := r.deps.Sessions.GetSelectedDashboard(ctx)
		if err != nil {
			return nil, err
		}
		userId = dashboardId
	}

	if userId == "" {
		return nil, fmt.Errorf("channelID is required")
	}

	badges, err := r.deps.TwitchService.GetChannelChatBadges(ctx, userId)
	if err != nil {
		return nil, err
	}

	mappedBadges := make([]gqlmodel.TwitchBadge, 0, len(badges))
	for _, badge := range badges {
		mappedBadges = append(mappedBadges, mappers.TwitchBadgeTo(badge))
	}

	return &gqlmodel.TwirTwitchChannelBadgeResponse{
		Badges: mappedBadges,
	}, nil
}

// TwitchGetGlobalBadges is the resolver for the twitchGetGlobalBadges field.
func (r *queryResolver) TwitchGetGlobalBadges(ctx context.Context) (*gqlmodel.TwirTwitchGlobalBadgeResponse, error) {
	badges, err := r.deps.TwitchService.GetGlobalChatBadges(ctx)
	if err != nil {
		return nil, err
	}

	mappedBadges := make([]gqlmodel.TwitchBadge, 0, len(badges))
	for _, badge := range badges {
		mappedBadges = append(mappedBadges, mappers.TwitchBadgeTo(badge))
	}

	return &gqlmodel.TwirTwitchGlobalBadgeResponse{
		Badges: mappedBadges,
	}, nil
}

// TwitchSearchCategories is the resolver for the twitchSearchCategories field.
func (r *queryResolver) TwitchSearchCategories(ctx context.Context, query string) (*gqlmodel.TwitchSearchCategoriesResponse, error) {
	if query == "" {
		return &gqlmodel.TwitchSearchCategoriesResponse{
			Categories: []gqlmodel.TwitchCategory{},
		}, nil
	}

	categories, err := r.deps.TwitchService.SearchCategories(
		ctx,
		twitch.SearchCategoriesInput{
			Query: query,
		},
	)
	if err != nil {
		return nil, err
	}

	mappedCategories := make([]gqlmodel.TwitchCategory, 0, len(categories))
	for _, category := range categories {
		mappedCategories = append(
			mappedCategories, gqlmodel.TwitchCategory{
				ID:        category.ID,
				Name:      category.Name,
				BoxArtURL: category.BoxArtURL,
			},
		)
	}

	return &gqlmodel.TwitchSearchCategoriesResponse{
		Categories: mappedCategories,
	}, nil
}

// TwitchGetCategories is the resolver for the twitchGetCategories field.
func (r *queryResolver) TwitchGetCategories(ctx context.Context, ids []string) (*gqlmodel.TwitchSearchCategoriesResponse, error) {
	if len(ids) == 0 {
		return &gqlmodel.TwitchSearchCategoriesResponse{
			Categories: []gqlmodel.TwitchCategory{},
		}, nil
	}

	games, err := r.deps.TwitchService.GetCategories(
		ctx,
		twitch.GetCategoriesInput{
			IDs: ids,
		},
	)
	if err != nil {
		return nil, err
	}

	mappedCategories := make([]gqlmodel.TwitchCategory, 0, len(games))
	for _, game := range games {
		mappedCategories = append(
			mappedCategories, gqlmodel.TwitchCategory{
				ID:        game.ID,
				Name:      game.Name,
				BoxArtURL: game.BoxArtURL,
			},
		)
	}

	return &gqlmodel.TwitchSearchCategoriesResponse{
		Categories: mappedCategories,
	}, nil
}
