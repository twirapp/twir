package resolvers

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"

	"github.com/goccy/go-json"
	"github.com/google/uuid"
	"github.com/samber/lo"
	data_loader "github.com/twirapp/twir/apps/api-gql/internal/delivery/gql/dataloader"
	"github.com/twirapp/twir/apps/api-gql/internal/delivery/gql/gqlmodel"
	"github.com/twirapp/twir/apps/api-gql/internal/delivery/gql/graph"
	"github.com/twirapp/twir/apps/api-gql/internal/delivery/gql/mappers"
	"github.com/twirapp/twir/apps/api-gql/internal/services/giveaways"
	giveawaysbus "github.com/twirapp/twir/libs/bus-core/giveaways"
	channelsgiveawayentity "github.com/twirapp/twir/libs/entities/channels_giveaways"
	"github.com/twirapp/twir/libs/entities/channels_giveaways_settings"
	"github.com/twirapp/twir/libs/logger"
)

// Winners is the resolver for the winners field.
func (r *channelGiveawayResolver) Winners(ctx context.Context, obj *gqlmodel.ChannelGiveaway) ([]gqlmodel.ChannelGiveawayWinner, error) {
	parsedID, err := uuid.Parse(obj.ID)
	if err != nil {
		return nil, err
	}

	winners, err := r.deps.GiveawaysService.GetParticipantsForGiveaway(
		ctx,
		parsedID,
		giveaways.GetParticipantsInput{OnlyWinners: true},
	)
	if err != nil {
		return nil, err
	}

	mappedWinners := make([]gqlmodel.ChannelGiveawayWinner, 0, len(winners))
	for _, winner := range winners {
		mappedWinners = append(
			mappedWinners,
			gqlmodel.ChannelGiveawayWinner{
				DisplayName: winner.DisplayName,
				UserID:      winner.UserID,
				UserLogin:   winner.UserLogin,
			},
		)
	}

	return mappedWinners, nil
}

// Participants is the resolver for the participants field.
func (r *channelGiveawayResolver) Participants(ctx context.Context, obj *gqlmodel.ChannelGiveaway) ([]gqlmodel.ChannelGiveawayParticipants, error) {
	parsedID, err := uuid.Parse(obj.ID)
	if err != nil {
		return nil, err
	}

	dbParticipants, err := r.deps.GiveawaysService.GetParticipantsForGiveaway(
		ctx,
		parsedID,
		giveaways.GetParticipantsInput{},
	)
	if err != nil {
		return nil, err
	}

	mappedParticipants := make([]gqlmodel.ChannelGiveawayParticipants, 0, len(dbParticipants))
	for _, participant := range dbParticipants {
		mappedParticipants = append(
			mappedParticipants,
			mappers.GiveawayParticipantEntityTo(participant),
		)
	}

	return mappedParticipants, nil
}

// TwitchProfile is the resolver for the twitchProfile field.
func (r *channelGiveawayWinnerResolver) TwitchProfile(ctx context.Context, obj *gqlmodel.ChannelGiveawayWinner) (*gqlmodel.TwirUserTwitchInfo, error) {
	return data_loader.GetHelixUserById(ctx, obj.UserID)
}

// GiveawaysCreate is the resolver for the giveawaysCreate field.
func (r *mutationResolver) GiveawaysCreate(ctx context.Context, opts gqlmodel.GiveawaysCreateInput) (*gqlmodel.ChannelGiveaway, error) {
	dashboardId, err := r.deps.Sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return nil, err
	}

	user, err := r.deps.Sessions.GetAuthenticatedUserModel(ctx)
	if err != nil {
		return nil, err
	}

	var minWatchedTime, minUsedChannelPoints, minFollowDuration *int64
	var minMessages *int32
	var requireSubscription bool

	if opts.Filters.IsSet() && opts.Filters.Value() != nil {
		filters := opts.Filters.Value()
		if filters.MinWatchedTime.IsSet() && filters.MinWatchedTime.Value() != nil {
			val := int64(*filters.MinWatchedTime.Value())
			minWatchedTime = &val
		}
		if filters.MinMessages.IsSet() && filters.MinMessages.Value() != nil {
			val := int32(*filters.MinMessages.Value())
			minMessages = &val
		}
		if filters.MinUsedChannelPoints.IsSet() && filters.MinUsedChannelPoints.Value() != nil {
			val := int64(*filters.MinUsedChannelPoints.Value())
			minUsedChannelPoints = &val
		}
		if filters.MinFollowDuration.IsSet() && filters.MinFollowDuration.Value() != nil {
			val := int64(*filters.MinFollowDuration.Value())
			minFollowDuration = &val
		}
		if filters.RequireSubscription.IsSet() && filters.RequireSubscription.Value() != nil {
			requireSubscription = *filters.RequireSubscription.Value()
		}
	}

	dbGiveaway, err := r.deps.GiveawaysService.Create(
		ctx, giveaways.CreateInput{
			ChannelID:            dashboardId,
			Type:                 channelsgiveawayentity.GiveawayType(opts.Type),
			Keyword:              opts.Keyword.Value(),
			MinWatchedTime:       minWatchedTime,
			MinMessages:          minMessages,
			MinUsedChannelPoints: minUsedChannelPoints,
			MinFollowDuration:    minFollowDuration,
			RequireSubscription:  requireSubscription,
			CreatedByUserID:      user.ID,
		},
	)
	if err != nil {
		return nil, err
	}

	converted := mappers.GiveawayEntityTo(dbGiveaway)
	return &converted, nil
}

// GiveawaysUpdate is the resolver for the giveawaysUpdate field.
func (r *mutationResolver) GiveawaysUpdate(ctx context.Context, id string, opts gqlmodel.GiveawaysUpdateInput) (*gqlmodel.ChannelGiveaway, error) {
	dashboardId, err := r.deps.Sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return nil, err
	}

	parsedID, err := uuid.Parse(id)
	if err != nil {
		return nil, err
	}

	var minWatchedTime, minUsedChannelPoints, minFollowDuration *int64
	var minMessages *int32
	var requireSubscription *bool

	if opts.Filters.IsSet() && opts.Filters.Value() != nil {
		filters := opts.Filters.Value()
		if filters.MinWatchedTime.IsSet() && filters.MinWatchedTime.Value() != nil {
			val := int64(*filters.MinWatchedTime.Value())
			minWatchedTime = &val
		}
		if filters.MinMessages.IsSet() && filters.MinMessages.Value() != nil {
			val := int32(*filters.MinMessages.Value())
			minMessages = &val
		}
		if filters.MinUsedChannelPoints.IsSet() && filters.MinUsedChannelPoints.Value() != nil {
			val := int64(*filters.MinUsedChannelPoints.Value())
			minUsedChannelPoints = &val
		}
		if filters.MinFollowDuration.IsSet() && filters.MinFollowDuration.Value() != nil {
			val := int64(*filters.MinFollowDuration.Value())
			minFollowDuration = &val
		}
		if filters.RequireSubscription.IsSet() && filters.RequireSubscription.Value() != nil {
			requireSubscription = filters.RequireSubscription.Value()
		}
	}

	dbGiveaway, err := r.deps.GiveawaysService.GiveawayUpdate(
		ctx, parsedID, dashboardId, giveaways.UpdateInput{
			StartedAt:            opts.StartedAt.Value(),
			Keyword:              opts.Keyword.Value(),
			StoppedAt:            opts.StoppedAt.Value(),
			MinWatchedTime:       minWatchedTime,
			MinMessages:          minMessages,
			MinUsedChannelPoints: minUsedChannelPoints,
			MinFollowDuration:    minFollowDuration,
			RequireSubscription:  requireSubscription,
		},
	)
	if err != nil {
		return nil, err
	}

	converted := mappers.GiveawayEntityTo(dbGiveaway)
	return &converted, nil
}

// GiveawaysRemove is the resolver for the giveawaysRemove field.
func (r *mutationResolver) GiveawaysRemove(ctx context.Context, id string) (*gqlmodel.ChannelGiveaway, error) {
	dashboardId, err := r.deps.Sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return nil, err
	}

	parsedID, err := uuid.Parse(id)
	if err != nil {
		return nil, err
	}

	return nil, r.deps.GiveawaysService.GiveawayRemove(ctx, parsedID, dashboardId)
}

// GiveawaysStart is the resolver for the giveawaysStart field.
func (r *mutationResolver) GiveawaysStart(ctx context.Context, id string) (*gqlmodel.ChannelGiveaway, error) {
	dashboardId, err := r.deps.Sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return nil, err
	}

	parsedID, err := uuid.Parse(id)
	if err != nil {
		return nil, err
	}

	dbGiveaway, err := r.deps.GiveawaysService.Start(ctx, parsedID, dashboardId)
	if err != nil {
		return nil, err
	}

	converted := mappers.GiveawayEntityTo(dbGiveaway)
	return &converted, nil
}

// GiveawaysStop is the resolver for the giveawaysStop field.
func (r *mutationResolver) GiveawaysStop(ctx context.Context, id string) (*gqlmodel.ChannelGiveaway, error) {
	dashboardId, err := r.deps.Sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return nil, err
	}

	parsedID, err := uuid.Parse(id)
	if err != nil {
		return nil, err
	}

	dbGiveaway, err := r.deps.GiveawaysService.Stop(ctx, parsedID, dashboardId)
	if err != nil {
		return nil, err
	}

	converted := mappers.GiveawayEntityTo(dbGiveaway)
	return &converted, nil
}

// GiveawaysChooseWinners is the resolver for the giveawaysChooseWinners field.
func (r *mutationResolver) GiveawaysChooseWinners(ctx context.Context, id string) ([]gqlmodel.ChannelGiveawayWinner, error) {
	dashboardId, err := r.deps.Sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return nil, err
	}

	parsedID, err := uuid.Parse(id)
	if err != nil {
		return nil, err
	}

	winners, err := r.deps.GiveawaysService.ChooseWinners(ctx, parsedID, dashboardId)
	if err != nil {
		return nil, err
	}

	mappedWinners := make([]gqlmodel.ChannelGiveawayWinner, 0, len(winners))
	for _, winner := range winners {
		mappedWinners = append(
			mappedWinners,
			mappers.GiveawayWinnerEntityTo(winner),
		)
	}

	return mappedWinners, nil
}

// GiveawaysSettingsUpdate is the resolver for the giveawaysSettingsUpdate field.
func (r *mutationResolver) GiveawaysSettingsUpdate(ctx context.Context, opts gqlmodel.GiveawaysSettingsUpdateInput) (*gqlmodel.GiveawaysSettings, error) {
	dashboardId, err := r.deps.Sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return nil, err
	}

	settings, err := r.deps.GiveawaysSettingsRepository.Update(
		ctx, dashboardId, channels_giveaways_settings.Settings{
			WinnerMessage: opts.WinnerMessage,
		},
	)
	if err != nil {
		return nil, err
	}

	converted := mappers.GiveawaySettingsEntityTo(settings)
	return &converted, nil
}

// Giveaways is the resolver for the giveaways field.
func (r *queryResolver) Giveaways(ctx context.Context) ([]gqlmodel.ChannelGiveaway, error) {
	dashboardId, err := r.deps.Sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return nil, err
	}

	dbGiveaways, err := r.deps.GiveawaysService.GiveawaysGetMany(ctx, dashboardId)
	if err != nil {
		return nil, err
	}

	converted := lo.Map(
		dbGiveaways, func(item channelsgiveawayentity.Giveaway, _ int) gqlmodel.ChannelGiveaway {
			return mappers.GiveawayEntityTo(item)
		},
	)

	return converted, nil
}

// Giveaway is the resolver for the giveaway field.
func (r *queryResolver) Giveaway(ctx context.Context, giveawayID string) (*gqlmodel.ChannelGiveaway, error) {
	dashboardId, err := r.deps.Sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return nil, err
	}

	parsedID, err := uuid.Parse(giveawayID)
	if err != nil {
		return nil, err
	}

	dbGiveaway, err := r.deps.GiveawaysService.GiveawayGet(ctx, parsedID, dashboardId)
	if err != nil {
		return nil, err
	}

	converted := mappers.GiveawayEntityTo(dbGiveaway)
	return &converted, nil
}

// GiveawaysSettings is the resolver for the giveawaysSettings field.
func (r *queryResolver) GiveawaysSettings(ctx context.Context) (*gqlmodel.GiveawaysSettings, error) {
	dashboardId, err := r.deps.Sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return nil, err
	}

	settings, err := r.deps.GiveawaysSettingsRepository.GetByChannelID(ctx, dashboardId)
	if err != nil {
		return nil, err
	}

	converted := mappers.GiveawaySettingsEntityTo(settings)
	return &converted, nil
}

// GiveawaysParticipants is the resolver for the giveawaysParticipants field.
func (r *subscriptionResolver) GiveawaysParticipants(ctx context.Context, giveawayID string) (<-chan *gqlmodel.ChannelGiveawaySubscriptionParticipant, error) {
	channel := make(chan *gqlmodel.ChannelGiveawaySubscriptionParticipant, 1)

	go func() {
		sub, err := r.deps.WsRouter.Subscribe(
			[]string{
				giveaways.CreateNewParticipantSubscriptionKeyByGiveawayID(giveawayID),
			},
		)
		if err != nil {
			r.deps.Logger.Error("subscription", logger.Error(err))
			return
		}
		defer func() {
			sub.Unsubscribe()
			close(channel)
		}()

		for {
			select {
			case <-ctx.Done():
				return
			case data := <-sub.GetChannel():
				var notification giveawaysbus.NewParticipant
				if err := json.Unmarshal(data, &notification); err != nil {
					r.deps.Logger.Error("cannot parse participant", logger.Error(err))
					continue
				}

				channel <- &gqlmodel.ChannelGiveawaySubscriptionParticipant{
					UserID:          notification.UserID,
					UserLogin:       notification.UserLogin,
					UserDisplayName: notification.UserDisplayName,
					GiveawayID:      notification.GiveawayID,
					IsWinner:        false,
				}
			}
		}
	}()

	return channel, nil
}

// ChannelGiveaway returns graph.ChannelGiveawayResolver implementation.
func (r *Resolver) ChannelGiveaway() graph.ChannelGiveawayResolver {
	return &channelGiveawayResolver{r}
}

// ChannelGiveawayWinner returns graph.ChannelGiveawayWinnerResolver implementation.
func (r *Resolver) ChannelGiveawayWinner() graph.ChannelGiveawayWinnerResolver {
	return &channelGiveawayWinnerResolver{r}
}

type channelGiveawayResolver struct{ *Resolver }
type channelGiveawayWinnerResolver struct{ *Resolver }
