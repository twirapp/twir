package resolvers

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/google/uuid"
	"github.com/twirapp/twir/apps/api-gql/internal/delivery/gql/gqlmodel"
	"github.com/twirapp/twir/apps/api-gql/internal/delivery/gql/mappers"
	"github.com/twirapp/twir/apps/api-gql/internal/services/channels_overlays"
	customoverlayentity "github.com/twirapp/twir/libs/entities/custom_overlay"
	"github.com/twirapp/twir/libs/logger"
)

// ChannelOverlayCreate is the resolver for the channelOverlayCreate field.
func (r *mutationResolver) ChannelOverlayCreate(ctx context.Context, input gqlmodel.ChannelOverlayCreateInput) (*gqlmodel.ChannelOverlay, error) {
	dashboardId, err := r.deps.Sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return nil, err
	}

	user, err := r.deps.Sessions.GetAuthenticatedUserModel(ctx)
	if err != nil {
		return nil, err
	}

	layers := make([]channels_overlays.CreateLayerInput, len(input.Layers))
	for i, l := range input.Layers {
		layers[i] = channels_overlays.CreateLayerInput{
			Type: mappers.ChannelOverlayLayerTypeGqlToEntity(l.Type),
			Settings: customoverlayentity.ChannelOverlayLayerSettings{
				HtmlOverlayHTML:                    l.Settings.HTMLOverlayHTML,
				HtmlOverlayCSS:                     l.Settings.HTMLOverlayCSS,
				HtmlOverlayJS:                      l.Settings.HTMLOverlayJs,
				HtmlOverlayDataPollSecondsInterval: l.Settings.HTMLOverlayDataPollSecondsInterval,
				ImageUrl:                           l.Settings.ImageURL,
			},
			PosX:                    l.PosX,
			PosY:                    l.PosY,
			Width:                   l.Width,
			Height:                  l.Height,
			Rotation:                l.Rotation,
			PeriodicallyRefetchData: l.PeriodicallyRefetchData,
			Locked:                  l.Locked,
			Visible:                 l.Visible,
			Opacity:                 l.Opacity,
		}
	}

	overlay, err := r.deps.ChannelOverlaysService.Create(
		ctx,
		channels_overlays.CreateInput{
			ChannelID: dashboardId,
			ActorID:   user.ID,
			Name:      input.Name,
			Width:     input.Width,
			Height:    input.Height,
			InstaSave: input.InstaSave,
			Layers:    layers,
		},
	)
	if err != nil {
		return nil, err
	}

	converted := mappers.ChannelOverlayEntityToGql(overlay)
	return &converted, nil
}

// ChannelOverlayUpdate is the resolver for the channelOverlayUpdate field.
func (r *mutationResolver) ChannelOverlayUpdate(ctx context.Context, id uuid.UUID, input gqlmodel.ChannelOverlayUpdateInput) (*gqlmodel.ChannelOverlay, error) {
	dashboardId, err := r.deps.Sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return nil, err
	}

	user, err := r.deps.Sessions.GetAuthenticatedUserModel(ctx)
	if err != nil {
		return nil, err
	}

	layers := make([]channels_overlays.UpdateLayerInput, len(input.Layers))
	for i, l := range input.Layers {
		var layerID *uuid.UUID
		if l.ID.IsSet() {
			layerID = l.ID.Value()
		}

		layers[i] = channels_overlays.UpdateLayerInput{
			ID:   layerID,
			Type: mappers.ChannelOverlayLayerTypeGqlToEntity(l.Type),
			Settings: customoverlayentity.ChannelOverlayLayerSettings{
				HtmlOverlayHTML:                    l.Settings.HTMLOverlayHTML,
				HtmlOverlayCSS:                     l.Settings.HTMLOverlayCSS,
				HtmlOverlayJS:                      l.Settings.HTMLOverlayJs,
				HtmlOverlayDataPollSecondsInterval: l.Settings.HTMLOverlayDataPollSecondsInterval,
				ImageUrl:                           l.Settings.ImageURL,
			},
			PosX:                    l.PosX,
			PosY:                    l.PosY,
			Width:                   l.Width,
			Height:                  l.Height,
			Rotation:                l.Rotation,
			PeriodicallyRefetchData: l.PeriodicallyRefetchData,
			Locked:                  l.Locked,
			Visible:                 l.Visible,
			Opacity:                 l.Opacity,
		}
	}

	overlay, err := r.deps.ChannelOverlaysService.Update(
		ctx,
		id,
		channels_overlays.UpdateInput{
			ChannelID: dashboardId,
			ActorID:   user.ID,
			Name:      input.Name,
			Width:     input.Width,
			Height:    input.Height,
			InstaSave: input.InstaSave,
			Layers:    layers,
		},
	)
	if err != nil {
		return nil, err
	}

	converted := mappers.ChannelOverlayEntityToGql(overlay)
	return &converted, nil
}

// ChannelOverlayDelete is the resolver for the channelOverlayDelete field.
func (r *mutationResolver) ChannelOverlayDelete(ctx context.Context, id uuid.UUID) (bool, error) {
	dashboardId, err := r.deps.Sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return false, err
	}

	user, err := r.deps.Sessions.GetAuthenticatedUserModel(ctx)
	if err != nil {
		return false, err
	}

	err = r.deps.ChannelOverlaysService.Delete(ctx, id, dashboardId, user.ID)
	if err != nil {
		return false, err
	}

	return true, nil
}

// ChannelOverlayParseHTML is the resolver for the channelOverlayParseHtml field.
func (r *mutationResolver) ChannelOverlayParseHTML(ctx context.Context, html string) (string, error) {
	dashboardId, err := r.deps.Sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return "", err
	}

	result, err := r.deps.ChannelOverlaysService.ParseHtml(
		ctx,
		channels_overlays.ParseHtmlInput{
			ChannelID: dashboardId,
			Html:      html,
		},
	)
	if err != nil {
		return "", err
	}

	return result, nil
}

// ChannelOverlays is the resolver for the channelOverlays field.
func (r *queryResolver) ChannelOverlays(ctx context.Context) ([]gqlmodel.ChannelOverlay, error) {
	dashboardId, err := r.deps.Sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return nil, err
	}

	overlays, err := r.deps.ChannelOverlaysService.GetManyByChannelID(ctx, dashboardId)
	if err != nil {
		return nil, err
	}

	result := make([]gqlmodel.ChannelOverlay, len(overlays))
	for i, o := range overlays {
		result[i] = mappers.ChannelOverlayEntityToGql(o)
	}

	return result, nil
}

// ChannelOverlayByID is the resolver for the channelOverlayById field.
func (r *queryResolver) ChannelOverlayByID(ctx context.Context, id uuid.UUID) (*gqlmodel.ChannelOverlay, error) {
	dashboardId, err := r.deps.Sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return nil, err
	}

	overlay, err := r.deps.ChannelOverlaysService.GetByID(ctx, id)
	if err != nil {
		return nil, err
	}

	if overlay.ChannelID != dashboardId {
		return nil, nil
	}

	converted := mappers.ChannelOverlayEntityToGql(overlay)
	return &converted, nil
}

// CustomOverlaySettings is the resolver for the customOverlaySettings field.
func (r *subscriptionResolver) CustomOverlaySettings(ctx context.Context, id uuid.UUID, apiKey string) (<-chan *gqlmodel.ChannelOverlay, error) {
	user, err := r.deps.UsersService.GetByApiKey(ctx, apiKey)
	if err != nil {
		return nil, err
	}

	channel := make(chan *gqlmodel.ChannelOverlay)

	// Get initial overlay data
	initialOverlay, err := r.deps.ChannelOverlaysService.GetByID(ctx, id)
	if err != nil {
		return nil, err
	}

	// Verify that the overlay belongs to the user's channel
	if initialOverlay.ChannelID != user.ID {
		return nil, fmt.Errorf("overlay not found")
	}

	go func() {
		sub, err := r.deps.WsRouter.Subscribe(
			[]string{
				channels_overlays.CreateCustomOverlayWsRouterKey(user.ID, id),
			},
		)
		if err != nil {
			panic(err)
		}
		defer func() {
			sub.Unsubscribe()
			close(channel)
		}()

		// Send initial data
		mappedInitialOverlay := mappers.ChannelOverlayEntityToGql(initialOverlay)
		channel <- &mappedInitialOverlay

		for {
			select {
			case <-ctx.Done():
				return
			case data := <-sub.GetChannel():
				var overlay customoverlayentity.ChannelOverlay
				if err := json.Unmarshal(data, &overlay); err != nil {
					r.deps.Logger.Error("cannot unmarshal custom overlay settings", logger.Error(err))
					continue
				}

				convertedOverlay := mappers.ChannelOverlayEntityToGql(overlay)
				channel <- &convertedOverlay
			}
		}
	}()

	return channel, nil
}
