package resolvers

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"

	"github.com/google/uuid"
	"github.com/twirapp/twir/apps/api-gql/internal/delivery/gql/gqlmodel"
	"github.com/twirapp/twir/apps/api-gql/internal/delivery/gql/mappers"
	"github.com/twirapp/twir/apps/api-gql/internal/services/channels_moderation_settings"
)

// ModerationSettingsCreate is the resolver for the moderationSettingsCreate field.
func (r *mutationResolver) ModerationSettingsCreate(ctx context.Context, input gqlmodel.ModerationSettingsCreateOrUpdateInput) (*gqlmodel.ModerationSettingsItem, error) {
	dashboardID, err := r.deps.Sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return nil, err
	}

	createInput := channels_moderation_settings.CreateOrUpdateInput{
		Name:                            input.Name.Value(),
		ChannelID:                       dashboardID,
		Type:                            mappers.ModerationSettingsTypeToEntity(input.Type),
		Enabled:                         input.Enabled,
		BanTime:                         int32(input.BanTime),
		BanMessage:                      input.BanMessage,
		WarningMessage:                  input.WarningMessage,
		CheckClips:                      input.CheckClips,
		TriggerLength:                   input.TriggerLength,
		MaxPercentage:                   input.MaxPercentage,
		DenyList:                        input.DenyList,
		DenyListRegexpEnabled:           input.DenyListRegexpEnabled,
		DenyListWordBoundaryEnabled:     input.DenyListWordBoundaryEnabled,
		DenyListSensitivityEnabled:      input.DenyListSensitivityEnabled,
		DeniedChatLanguages:             input.DeniedChatLanguages,
		ExcludedRoles:                   input.ExcludedRoles,
		MaxWarnings:                     input.MaxWarnings,
		OneManSpamMinimumStoredMessages: input.OneManSpamMinimumStoredMessages,
		OneManSpamMessageMemorySeconds:  input.OneManSpamMessageMemorySeconds,
		LanguageExcludedWords:           input.LanguageExcludedWords,
	}

	newItem, err := r.deps.ChannelsModerationSettingsService.Create(ctx, createInput)
	if err != nil {
		return nil, err
	}

	mappedItem := mappers.ModerationSettingsEntityToGql(newItem)
	return &mappedItem, nil
}

// ModerationSettingsUpdate is the resolver for the moderationSettingsUpdate field.
func (r *mutationResolver) ModerationSettingsUpdate(ctx context.Context, id uuid.UUID, input gqlmodel.ModerationSettingsCreateOrUpdateInput) (*gqlmodel.ModerationSettingsItem, error) {
	dashboardID, err := r.deps.Sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return nil, err
	}

	createInput := channels_moderation_settings.CreateOrUpdateInput{
		Name:                            input.Name.Value(),
		ChannelID:                       dashboardID,
		Type:                            mappers.ModerationSettingsTypeToEntity(input.Type),
		Enabled:                         input.Enabled,
		BanTime:                         int32(input.BanTime),
		BanMessage:                      input.BanMessage,
		WarningMessage:                  input.WarningMessage,
		CheckClips:                      input.CheckClips,
		TriggerLength:                   input.TriggerLength,
		MaxPercentage:                   input.MaxPercentage,
		DenyList:                        input.DenyList,
		DenyListRegexpEnabled:           input.DenyListRegexpEnabled,
		DenyListWordBoundaryEnabled:     input.DenyListWordBoundaryEnabled,
		DenyListSensitivityEnabled:      input.DenyListSensitivityEnabled,
		DeniedChatLanguages:             input.DeniedChatLanguages,
		ExcludedRoles:                   input.ExcludedRoles,
		MaxWarnings:                     input.MaxWarnings,
		OneManSpamMinimumStoredMessages: input.OneManSpamMinimumStoredMessages,
		OneManSpamMessageMemorySeconds:  input.OneManSpamMessageMemorySeconds,
		LanguageExcludedWords:           input.LanguageExcludedWords,
	}

	newItem, err := r.deps.ChannelsModerationSettingsService.Update(ctx, id, createInput)
	if err != nil {
		return nil, err
	}

	mappedItem := mappers.ModerationSettingsEntityToGql(newItem)
	return &mappedItem, nil
}

// ModerationSettingsDelete is the resolver for the moderationSettingsDelete field.
func (r *mutationResolver) ModerationSettingsDelete(ctx context.Context, id uuid.UUID) (bool, error) {
	dashboardID, err := r.deps.Sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return false, err
	}

	err = r.deps.ChannelsModerationSettingsService.Delete(ctx, id, dashboardID)
	if err != nil {
		return false, err
	}

	return true, nil
}

// ModerationSettings is the resolver for the moderationSettings field.
func (r *queryResolver) ModerationSettings(ctx context.Context) ([]gqlmodel.ModerationSettingsItem, error) {
	dashboardID, err := r.deps.Sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return nil, err
	}

	items, err := r.deps.ChannelsModerationSettingsService.GetByChannelID(ctx, dashboardID)
	if err != nil {
		return nil, err
	}

	converted := make([]gqlmodel.ModerationSettingsItem, 0, len(items))
	for _, item := range items {
		converted = append(converted, mappers.ModerationSettingsEntityToGql(item))
	}

	return converted, nil
}

// ModerationLanguagesAvailableLanguages is the resolver for the moderationLanguagesAvailableLanguages field.
func (r *queryResolver) ModerationLanguagesAvailableLanguages(ctx context.Context) (*gqlmodel.ModerationLanguagesAvailableLanguagesOutput, error) {
	type availableLanguage struct {
		Iso6391 string `json:"iso_639_1"`
		Name    string `json:"name"`
	}

	var reqUrl string
	if r.deps.Config.AppEnv == "production" {
		reqUrl = fmt.Sprint("http://language-processor:3012")
	} else {
		reqUrl = "http://localhost:3012"
	}

	req, err := http.NewRequestWithContext(ctx, http.MethodGet, reqUrl+"/detect/languages", nil)
	if err != nil {
		return nil, err
	}

	res, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()

	body, err := io.ReadAll(res.Body)
	if err != nil {
		return nil, err
	}

	if res.StatusCode < 200 || res.StatusCode >= 300 {
		return nil, errors.New("cannot get response")
	}

	var resp []availableLanguage
	if err := json.Unmarshal(body, &resp); err != nil {
		return nil, err
	}

	gqlResp := &gqlmodel.ModerationLanguagesAvailableLanguagesOutput{
		Languages: make([]gqlmodel.ModerationLanguagesAvailableLanguage, 0, len(resp)),
	}

	for _, lang := range resp {
		gqlResp.Languages = append(
			gqlResp.Languages,
			gqlmodel.ModerationLanguagesAvailableLanguage{
				Iso639_1: lang.Iso6391,
				Name:     lang.Name,
			},
		)
	}

	return gqlResp, nil
}
