package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"github.com/twirapp/twir/apps/api-gql/internal/delivery/gql/dataloader"
	"github.com/twirapp/twir/apps/api-gql/internal/delivery/gql/gqlmodel"
	"github.com/twirapp/twir/apps/api-gql/internal/delivery/gql/graph"
	"github.com/twirapp/twir/apps/api-gql/internal/delivery/gql/mappers"
	"github.com/twirapp/twir/apps/api-gql/internal/entity"
	"github.com/twirapp/twir/apps/api-gql/internal/services/overlays/tts"
	model "github.com/twirapp/twir/libs/gomodels"
)

// OverlaysTTSUpdate is the resolver for the overlaysTTSUpdate field.
func (r *mutationResolver) OverlaysTTSUpdate(ctx context.Context, input gqlmodel.TTSUpdateInput) (*gqlmodel.TTSOverlay, error) {
	dashboardID, err := r.deps.Sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return nil, err
	}

	updateInput := entity.TTSOverlaySettings{
		Enabled:                            input.Enabled,
		Voice:                              input.Voice,
		DisallowedVoices:                   input.DisallowedVoices,
		Pitch:                              int32(input.Pitch),
		Rate:                               int32(input.Rate),
		Volume:                             int32(input.Volume),
		DoNotReadTwitchEmotes:              input.DoNotReadTwitchEmotes,
		DoNotReadEmoji:                     input.DoNotReadEmoji,
		DoNotReadLinks:                     input.DoNotReadLinks,
		AllowUsersChooseVoiceInMainCommand: input.AllowUsersChooseVoiceInMainCommand,
		MaxSymbols:                         int32(input.MaxSymbols),
		ReadChatMessages:                   input.ReadChatMessages,
		ReadChatMessagesNicknames:          input.ReadChatMessagesNicknames,
	}

	updatedOverlay, err := r.deps.TTSService.Update(
		ctx, tts.UpdateInput{
			ChannelID: dashboardID,
			Settings:  updateInput,
		},
	)
	if err != nil {
		return nil, fmt.Errorf("failed to update tts overlay: %w", err)
	}

	converted := mappers.MapTTSOverlayEntityToGQL(updatedOverlay)
	return &converted, nil
}

// OverlaysTTSUsersDelete is the resolver for the overlaysTTSUsersDelete field.
func (r *mutationResolver) OverlaysTTSUsersDelete(ctx context.Context, userIds []string) (bool, error) {
	dashboardID, err := r.deps.Sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return false, err
	}

	if err := r.deps.TTSService.DeleteUsersSettings(ctx, dashboardID, userIds); err != nil {
		return false, fmt.Errorf("failed to delete tts users settings: %w", err)
	}

	return true, nil
}

// OverlaysTts is the resolver for the overlaysTTS field.
func (r *queryResolver) OverlaysTts(ctx context.Context) (*gqlmodel.TTSOverlay, error) {
	dashboardID, err := r.deps.Sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return nil, err
	}

	overlay, err := r.deps.TTSService.GetOrCreate(ctx, dashboardID)
	if err != nil {
		return nil, fmt.Errorf("failed to get tts overlay: %w", err)
	}

	converted := mappers.MapTTSOverlayEntityToGQL(overlay)
	return &converted, nil
}

// OverlaysTTSGetInfo is the resolver for the overlaysTTSGetInfo field.
func (r *queryResolver) OverlaysTTSGetInfo(ctx context.Context) (*gqlmodel.TTSVoicesInfo, error) {
	info, err := r.deps.TTSService.GetInfo(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get tts info: %w", err)
	}
	voicesInfo := make([]gqlmodel.TTSVoiceInfoItem, 0, len(info.VoicesInfo))
	for key, voice := range info.VoicesInfo {
		voicesInfo = append(voicesInfo, gqlmodel.TTSVoiceInfoItem{
			Key: key,
			Info: &gqlmodel.TTSVoiceInfo{
				Country: voice.Country,
				Gender:  voice.Gender,
				Lang:    voice.Lang,
				Name:    voice.Name,
				No:      voice.No,
			},
		})
	}
	return &gqlmodel.TTSVoicesInfo{
		VoicesInfo: voicesInfo,
	}, nil
}

// OverlaysTTSUsersSettings is the resolver for the overlaysTTSUsersSettings field.
func (r *queryResolver) OverlaysTTSUsersSettings(ctx context.Context) ([]gqlmodel.TTSUserSettings, error) {
	dashboardID, err := r.deps.Sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return nil, err
	}

	settings, err := r.deps.TTSService.GetTTSUsersSettings(ctx, dashboardID)
	if err != nil {
		return nil, fmt.Errorf("failed to get tts users settings: %w", err)
	}

	mappedSettings := make([]gqlmodel.TTSUserSettings, 0, len(settings))
	for _, s := range settings {
		mappedSettings = append(mappedSettings, mappers.TTSUserSettingTo(s))
	}

	return mappedSettings, nil
}

// TtsPublicUsersSettings is the resolver for the ttsPublicUsersSettings field.
func (r *queryResolver) TtsPublicUsersSettings(ctx context.Context, channelID string) ([]gqlmodel.TTSUserSettings, error) {
	settings, err := r.deps.TTSService.GetTTSUsersSettings(ctx, channelID)
	if err != nil {
		return nil, fmt.Errorf("failed to get tts users settings: %w", err)
	}

	mappedSettings := make([]gqlmodel.TTSUserSettings, 0, len(settings))
	for _, s := range settings {
		mappedSettings = append(mappedSettings, mappers.TTSUserSettingTo(s))
	}

	return mappedSettings, nil
}

// OverlaysTts is the resolver for the overlaysTTS field.
func (r *subscriptionResolver) OverlaysTts(ctx context.Context, apiKey string) (<-chan *gqlmodel.TTSOverlay, error) {
	user := model.Users{}
	if err := r.deps.Gorm.Where(`"apiKey" = ?`, apiKey).First(&user).Error; err != nil {
		return nil, fmt.Errorf("failed to get user: %w", err)
	}

	createTTSSettingsSubscriptionKey := func(userID string) string {
		return fmt.Sprintf("overlays:tts:settings:%s", userID)
	}

	outputChan := make(chan *gqlmodel.TTSOverlay, 1)

	go func() {
		sub, err := r.deps.WsRouter.Subscribe(
			[]string{
				createTTSSettingsSubscriptionKey(user.ID),
			},
		)
		if err != nil {
			panic(err)
		}
		defer func() {
			sub.Unsubscribe()
			close(outputChan)
		}()

		initialSettings, err := r.deps.TTSService.GetOrCreate(ctx, user.ID)
		if err == nil {
			converted := mappers.MapTTSOverlayEntityToGQL(initialSettings)
			outputChan <- &converted
		}

		for {
			select {
			case <-ctx.Done():
				return
			case data := <-sub.GetChannel():
				var settings entity.TTSOverlay
				if err := json.Unmarshal(data, &settings); err != nil {
					panic(err)
				}

				converted := mappers.MapTTSOverlayEntityToGQL(settings)
				outputChan <- &converted
			}
		}
	}()

	return outputChan, nil
}

// OverlaysTTSSay is the resolver for the overlaysTTSSay field.
func (r *subscriptionResolver) OverlaysTTSSay(ctx context.Context, apiKey string) (<-chan *gqlmodel.TTSSayMessage, error) {
	sayChan, err := r.deps.TTSService.SaySubscriptionSignalerByApiKey(ctx, apiKey)
	if err != nil {
		return nil, fmt.Errorf("failed to subscribe to tts say: %w", err)
	}

	outputChan := make(chan *gqlmodel.TTSSayMessage, 1)

	go func() {
		defer close(outputChan)

		for {
			select {
			case <-ctx.Done():
				return
			case msg, ok := <-sayChan:
				if !ok {
					return
				}

				outputChan <- &gqlmodel.TTSSayMessage{
					Text:   msg.Text,
					Voice:  msg.Voice,
					Rate:   msg.Rate,
					Pitch:  msg.Pitch,
					Volume: msg.Volume,
				}
			}
		}
	}()

	return outputChan, nil
}

// OverlaysTTSSkip is the resolver for the overlaysTTSSkip field.
func (r *subscriptionResolver) OverlaysTTSSkip(ctx context.Context, apiKey string) (<-chan *time.Time, error) {
	skipChan, err := r.deps.TTSService.SkipSubscriptionSignalerByApiKey(ctx, apiKey)
	if err != nil {
		return nil, fmt.Errorf("failed to subscribe to tts skip: %w", err)
	}

	outputChan := make(chan *time.Time, 1)

	go func() {
		defer close(outputChan)

		for {
			select {
			case <-ctx.Done():
				return
			case _, ok := <-skipChan:
				if !ok {
					return
				}

				now := time.Now()
				outputChan <- &now
			}
		}
	}()

	return outputChan, nil
}

// Channel is the resolver for the channel field.
func (r *tTSOverlayResolver) Channel(ctx context.Context, obj *gqlmodel.TTSOverlay) (*gqlmodel.TwirUserTwitchInfo, error) {
	return dataloader.GetHelixUserById(ctx, obj.ChannelID)
}

// TwitchProfile is the resolver for the twitchProfile field.
func (r *tTSUserSettingsResolver) TwitchProfile(ctx context.Context, obj *gqlmodel.TTSUserSettings) (*gqlmodel.TwirUserTwitchInfo, error) {
	return dataloader.GetHelixUserById(ctx, obj.UserID)
}

// TTSOverlay returns graph.TTSOverlayResolver implementation.
func (r *Resolver) TTSOverlay() graph.TTSOverlayResolver { return &tTSOverlayResolver{r} }

// TTSUserSettings returns graph.TTSUserSettingsResolver implementation.
func (r *Resolver) TTSUserSettings() graph.TTSUserSettingsResolver {
	return &tTSUserSettingsResolver{r}
}

type tTSOverlayResolver struct{ *Resolver }
type tTSUserSettingsResolver struct{ *Resolver }
