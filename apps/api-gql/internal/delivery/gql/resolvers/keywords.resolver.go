package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76

import (
	"context"

	"github.com/google/uuid"
	"github.com/twirapp/twir/apps/api-gql/internal/delivery/gql/gqlmodel"
	"github.com/twirapp/twir/apps/api-gql/internal/delivery/gql/mappers"
	"github.com/twirapp/twir/apps/api-gql/internal/services/keywords"
)

// KeywordCreate is the resolver for the keywordCreate field.
func (r *mutationResolver) KeywordCreate(ctx context.Context, opts gqlmodel.KeywordCreateInput) (*gqlmodel.Keyword, error) {
	dashboardId, err := r.deps.Sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return nil, err
	}

	user, err := r.deps.Sessions.GetAuthenticatedUser(ctx)
	if err != nil {
		return nil, err
	}

	input := keywords.CreateInput{
		ChannelID: dashboardId,
		ActorID:   user.ID,
		Text:      opts.Text,
	}

	if opts.Response.IsSet() && opts.Response.Value() != nil {
		input.Response = *opts.Response.Value()
	}

	if opts.Enabled.IsSet() {
		input.Enabled = *opts.Enabled.Value()
	}

	if opts.Cooldown.IsSet() {
		input.Cooldown = *opts.Cooldown.Value()
	}

	if opts.IsReply.IsSet() {
		input.IsReply = *opts.IsReply.Value()
	}

	if opts.IsRegularExpression.IsSet() {
		input.IsRegular = *opts.IsRegularExpression.Value()
	}

	if opts.UsageCount.IsSet() {
		input.Usages = *opts.UsageCount.Value()
	}

	if opts.RolesIds.IsSet() {
		input.RolesIDs = opts.RolesIds.Value()
	}

	k, err := r.deps.KeywordsService.Create(ctx, input)
	if err != nil {
		return nil, err
	}

	converted := mappers.KeywordsFrom(k)
	return &converted, nil
}

// KeywordUpdate is the resolver for the keywordUpdate field.
func (r *mutationResolver) KeywordUpdate(ctx context.Context, id uuid.UUID, opts gqlmodel.KeywordUpdateInput) (*gqlmodel.Keyword, error) {
	dashboardId, err := r.deps.Sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return nil, err
	}

	user, err := r.deps.Sessions.GetAuthenticatedUser(ctx)
	if err != nil {
		return nil, err
	}

	input := keywords.UpdateInput{
		ChannelID:        dashboardId,
		ActorID:          user.ID,
		ID:               id,
		Text:             nil,
		Response:         nil,
		Enabled:          nil,
		Cooldown:         nil,
		CooldownExpireAt: nil,
		IsReply:          nil,
		IsRegular:        nil,
		Usages:           nil,
	}

	if opts.Text.IsSet() {
		input.Text = opts.Text.Value()
	}

	if opts.Response.IsSet() {
		input.Response = opts.Response.Value()
	}

	if opts.Enabled.IsSet() {
		input.Enabled = opts.Enabled.Value()
	}

	if opts.Cooldown.IsSet() {
		input.Cooldown = opts.Cooldown.Value()
	}

	if opts.IsReply.IsSet() {
		input.IsReply = opts.IsReply.Value()
	}

	if opts.IsRegularExpression.IsSet() {
		input.IsRegular = opts.IsRegularExpression.Value()
	}

	if opts.UsageCount.IsSet() {
		input.Usages = opts.UsageCount.Value()
	}

	if opts.RolesIds.IsSet() {
		input.RolesIDs = opts.RolesIds.Value()
	}

	keyword, err := r.deps.KeywordsService.Update(ctx, input)
	if err != nil {
		return nil, err
	}

	converted := mappers.KeywordsFrom(keyword)
	return &converted, nil
}

// KeywordRemove is the resolver for the keywordRemove field.
func (r *mutationResolver) KeywordRemove(ctx context.Context, id uuid.UUID) (bool, error) {
	dashboardId, err := r.deps.Sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return false, err
	}

	user, err := r.deps.Sessions.GetAuthenticatedUser(ctx)
	if err != nil {
		return false, err
	}

	if err := r.deps.KeywordsService.Delete(ctx, dashboardId, user.ID, id); err != nil {
		return false, err
	}

	return true, nil
}

// Keywords is the resolver for the keywords field.
func (r *queryResolver) Keywords(ctx context.Context) ([]gqlmodel.Keyword, error) {
	dashboardId, err := r.deps.Sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return nil, err
	}

	channelKeywords, err := r.deps.KeywordsService.GetAllByChannelID(ctx, dashboardId)
	if err != nil {
		return nil, err
	}

	converted := make([]gqlmodel.Keyword, 0, len(channelKeywords))
	for _, k := range channelKeywords {
		converted = append(converted, mappers.KeywordsFrom(k))
	}

	return converted, nil
}
