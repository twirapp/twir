package resolvers

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"

	"github.com/samber/lo"
	data_loader "github.com/twirapp/twir/apps/api-gql/internal/delivery/gql/dataloader"
	"github.com/twirapp/twir/apps/api-gql/internal/delivery/gql/gqlmodel"
	"github.com/twirapp/twir/apps/api-gql/internal/delivery/gql/graph"
	"github.com/twirapp/twir/apps/api-gql/internal/services/channels_redemptions_history"
)

// RewardsRedemptionsHistory is the resolver for the rewardsRedemptionsHistory field.
func (r *queryResolver) RewardsRedemptionsHistory(ctx context.Context, opts gqlmodel.TwitchRedemptionsOpts) (*gqlmodel.TwitchRedemptionResponse, error) {
	dashboardId, err := r.deps.Sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return nil, err
	}

	channelIdForRequest := dashboardId
	if opts.ByChannelID.IsSet() {
		channelIdForRequest = *opts.ByChannelID.Value()
	}

	page := 0
	perPage := 20
	if opts.Page.IsSet() {
		page = *opts.Page.Value()
	}
	if opts.PerPage.IsSet() {
		perPage = *opts.PerPage.Value()
	}

	if perPage > 100 {
		perPage = 100
	}

	serviceInput := channels_redemptions_history.GetManyInput{
		ChannelID:    channelIdForRequest,
		Page:         page,
		PerPage:      perPage,
		RewardsIDs:   opts.RewardsIds.Value(),
		UserNameLike: opts.UserSearch.Value(),
	}

	history, err := r.deps.ChannelsRedemptionsHistoryService.GetMany(ctx, serviceInput)
	if err != nil {
		return nil, err
	}

	rewards, err := r.Query().TwitchRewards(ctx, &channelIdForRequest)
	if err != nil {
		return nil, err
	}

	res := make([]gqlmodel.TwitchRedemption, 0, len(history.Items))
	for _, entity := range history.Items {
		reward := gqlmodel.TwitchReward{
			ID:        entity.RewardID.String(),
			Title:     entity.RewardTitle,
			Cost:      int(entity.RewardCost),
			ImageUrls: nil,
		}

		twitchReward, twitchRewardFound := lo.Find(
			rewards, func(r gqlmodel.TwitchReward) bool {
				return r.ID == entity.RewardID.String()
			},
		)
		if twitchRewardFound {
			reward.Title = twitchReward.Title
			reward.ImageUrls = twitchReward.ImageUrls
			reward.UsedTimes = twitchReward.UsedTimes
			reward.Enabled = twitchReward.Enabled
		}

		redemption := gqlmodel.TwitchRedemption{
			ID:         entity.RewardID.String(),
			ChannelID:  entity.ChannelID,
			RedeemedAt: entity.RedeemedAt,
			User:       &gqlmodel.TwirUserTwitchInfo{ID: entity.UserID},
			Reward:     &reward,
			Prompt:     entity.RewardPrompt,
		}

		res = append(res, redemption)
	}

	return &gqlmodel.TwitchRedemptionResponse{
		Redemptions: res,
		Total:       int(history.Total),
	}, nil
}

// RewardsActivation is the resolver for the rewardsActivation field.
func (r *subscriptionResolver) RewardsActivation(ctx context.Context) (<-chan *gqlmodel.TwitchRedemption, error) {
	dashboardID, err := r.deps.Sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return nil, err
	}

	subscription := r.deps.CommunityRedemptionsService.Subscribe(dashboardID)
	ch := make(chan *gqlmodel.TwitchRedemption, 1)

	go func() {
		defer func() {
			r.deps.CommunityRedemptionsService.Unsubscribe(dashboardID)
			close(ch)
		}()

		for {
			select {
			case <-ctx.Done():
				return
			case data := <-subscription:
				rewards, err := r.Query().TwitchRewards(ctx, &dashboardID)
				if err != nil {
					r.deps.Logger.Error("failed to get rewards", "error", err)
					continue
				}

				var reward *gqlmodel.TwitchReward
				for _, r := range rewards {
					if r.ID == data.Reward.ID {
						reward = &r
						break
					}
				}

				if reward == nil {
					r.deps.Logger.Error("reward not found", "reward_id", data.Reward.ID)
					continue
				}

				redemption := &gqlmodel.TwitchRedemption{
					ID:        data.ID,
					ChannelID: data.BroadcasterUserID,
					User:      &gqlmodel.TwirUserTwitchInfo{ID: data.UserID},
					Reward: &gqlmodel.TwitchReward{
						ID:              data.Reward.ID,
						Title:           reward.Title,
						Cost:            reward.Cost,
						ImageUrls:       reward.ImageUrls,
						BackgroundColor: reward.BackgroundColor,
						Enabled:         reward.Enabled,
						UsedTimes:       reward.UsedTimes,
					},
					RedeemedAt: data.RedeemedAt,
					Prompt:     &data.UserInput,
				}

				ch <- redemption
			}
		}
	}()

	return ch, nil
}

// User is the resolver for the user field.
func (r *twitchRedemptionResolver) User(ctx context.Context, obj *gqlmodel.TwitchRedemption) (*gqlmodel.TwirUserTwitchInfo, error) {
	return data_loader.GetHelixUserById(ctx, obj.User.ID)
}

// TwitchRedemption returns graph.TwitchRedemptionResolver implementation.
func (r *Resolver) TwitchRedemption() graph.TwitchRedemptionResolver {
	return &twitchRedemptionResolver{r}
}

type twitchRedemptionResolver struct{ *Resolver }
